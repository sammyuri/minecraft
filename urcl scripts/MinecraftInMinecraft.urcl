bits == 8
minreg 7
minheap 232
minstack 23

//constants
    //size constants
        @define BLOCKSIZE 16
        @define PLAYERWIDTH 9 //technically it's 10, but 9 makes calculations easier
        @define PLAYERHEIGHT 28 //technically it's 29, but 28 makes calculations easier
        @define PLAYERHALFWIDTH 5
        @define PLAYERCAMHEIGHT 24
        @define PICKUPDOWN 12
        @define PICKUPUP 37
        @define PICKUPSIDENEG 22
        @define PICKUPSIDEPOS 28
        @define PLAYERCROUCHCAMHEIGHT 22
        @define MIDDLEOFVOID 0b1010_0000
        @define BLOCKMIDDLEOFVOID 0b1100
    //gameplay constants
        @define GRAVITY 15 //the downwards change in velocity per frame
        @define JUMPSTRENGTH 17 //the initial vertical velocity of a jump
        @define SPEEDFACTOR 0b01_000000 //scales the speed of the characters movement. A value of 1 results in a speed of 4 while crouching, 8 while walking, and 12 while sprinting. In 0bSX.XXXXXX format
        @define RAYCASTMAXLENGTH 0x40 //4 blocks
        //@define REQUIREDBREAKSTRENGTH 8
        @define BREAKTIME 24 //scales how much time it takes to break a block
        @define MAXHEALTH 8 //NOTE: doesn't affect health rendering
        @define APPLEHEALTH 2
        @define MINFALLDAMAGESPEED 32
        @define FALLDAMAGESCALING 0b00_001000
    //other constants
        @define BOTTOMOFSTACK 255 //in URCX: minreg + minheap. in CHUNGUS: 0
    //block IDs
        @define BLOCK_AIR 0x0
        @define BLOCK_grass 0x1
        @define BLOCK_DIRT 0x2
        @define BLOCK_STONE 0x3
        @define BLOCK_COBBLE 0x4
        @define BLOCK_LOG 0x5
        @define BLOCK_LEAVES 0x6
        @define BLOCK_PLANK 0x7
        @define BLOCK_COALORE 0x8
        @define BLOCK_IRONORE 0x9
        @define BLOCK_SAND 0xA
        @define BLOCK_GLASS 0xB
        @define BLOCK_SAPLING 0xC
        @define BLOCK_TABLE 0xD
        @define BLOCK_FURNACE 0xE
        @define BLOCK_CHEST 0xF
    //item IDs
        @define ITEM_AIR 0x00
        @define ITEM_STICK 0x10
        @define ITEM_DIRT 0x20
        @define ITEM_STONE 0x30
        @define ITEM_COBBLE 0x40
        @define ITEM_LOG 0x50
        @define ITEM_LEAVES 0x60
        @define ITEM_PLANK 0x70
        @define ITEM_COAL 0x80
        @define ITEM_IRONORE 0x90
        @define ITEM_SAND 0xA0
        @define ITEM_GLASS 0xB0
        @define ITEM_SAPLING 0xC0
        @define ITEM_IRONINGOT 0xD0
        @define ITEM_APPLE 0xE0
        @define ITEM_NONSTACKABLE 0xF0
    //nonstackable IDs
        @define ITEM_WOODPICKAXE 0xF0
        @define ITEM_WOODAXE 0xF1
        @define ITEM_WOODSHOVEL 0xF2
        @define ITEM_WOODSWORD 0xF3
        @define ITEM_STONEPICKAXE 0xF4
        @define ITEM_STONEAXE 0xF5
        @define ITEM_STONESHOVEL 0xF6
        @define ITEM_STONESWORD 0xF7
        @define ITEM_IRONPICKAXE 0xF8
        @define ITEM_IRONAXE 0xF9
        @define ITEM_IRONSHOVEL 0xFA
        @define ITEM_IRONSWORD 0xFB
        @define ITEM_SHEARS 0xFC
        @define ITEM_TABLE 0xFD
        @define ITEM_FURNACE 0xFE
        @define ITEM_CHEST 0xFF
    //entity IDs
        //NOTE: item entities have the following structure in RAM:
            //byte 1: IIII_VVVV; I=id, V=y-velocity
            //byte 2: XXX.X_ZZZ.Z
            //byte 3: 0YYY.YYYY
        @define ENTITY_STICK 0x1
        @define ENTITY_DIRT 0x2
        @define ENTITY_APPLE 0x3
        @define ENTITY_COBBLE 0x4
        @define ENTITY_LOG 0x5
        @define ENTITY_LEAVES 0x6
        @define ENTITY_PLANK 0x7
        @define ENTITY_COAL 0x8
        @define ENTITY_IRONORE 0x9
        @define ENTITY_SAND 0xA
        @define ENTITY_FALLINGSAND 0xB
        @define ENTITY_SAPLING 0xC
        @define ENTITY_TABLE 0xD
        @define ENTITY_FURNACE 0xE
        @define ENTITY_CHEST 0xF
    //textures
        @define TEXTURE_NUMBER 0x20
        @define TEXTURE_STACKABLE 0x40
        @define TEXTURE_NONSTACKABLE 0x50
        @define TEXTURE_GUI_EMPTY 0x61
        @define TEXTURE_GUI_ARROW 0x63
        @define TEXTURE_GUI_SMELTING 0x67
        @define TEXTURE_INVENTORY 0x70
        @define TEXTURE_CRAFT 0x75
        @define TEXTURE_FURNACE 0x78
        @define TEXTURE_CHEST 0x7C
        @define TEXTURE_HIGHLIGHT0 128
        @define TEXTURE_HIGHLIGHT7 135
        @define TEXTURE_HEARTEMPTY 136
        @define TEXTURE_HEARTFULL 137
    //other
        @define TOOL_PICKAXE 0
        @define TOOL_AXE 1
        @define TOOL_SHOVEL 2
        @define TOOL_SWORD 3

        @define STRENGTHFORITEM 3
        @define STRENGTH_FIST 4
        @define STRENGTH_WOOD 5
        @define STRENGTH_STONE 6
        @define STRENGTH_IRON 7

        @define BLOCKTYPE_STONE 0
        @define BLOCKTYPE_WOOD 1
        @define BLOCKTYPE_SOFT 2
        @define BLOCKTYPE_LEAVES 3
        @define BLOCKTYPE_GLASS 4
        @define BLOCKTYPE_SAPLING 5

//memory locations
    //OPTIM: it might be worth placing some of these at the base of the stack instead of the heap to reduce cache misses
    @define x m0 //7 bits //NOTE: replace with '0' if 'm0' not supported in translator
    @define y m1 //8 bits
    @define z m2 //7 bits
    @define rot m3 //8 bits
    @define onGround m4 //1 bit
    @define velY m5 //6 bits
    @define needReRender m6 //1 bit
    @define crouching m7 //1 bit
    @define prevX m8 //7 bits
    @define prevY m9 //8 bits
    @define prevZ m10 //7 bits
    //@define prevTargetXZ m11 //8 bits XXXX_ZZZZ //NOTE: this address no longer in use
    //@define prevTargetY m12 //4 bits //NOTE: this address no longer in use
    @define inventory m11 //NOTE: takes up 15 cells (m13-m27), 8 bits each
    @define inventorySlot m26 //8 bits
    //@define breakPhase m29 //8 bits 0PPP_0CCC P=previous C=current //NOTE: this address no longer in use 
    //@define targetXZ m30 //8 bits XXXX_ZZZZ //NOTE: this address no longer in use
    //@define targetY m31 //4 bits //NOTE: this address no longer in use
    @define craftingGrid m27 //NOTE: takes up 9 cells (m32-m40), 8 bits each //NOTE: these cells can be used again in portions of the code that don't interfere with crafting.
    @define craftingOutput m36 //8 bits //NOTE: this cell can be used again in portions of the code that don't interfere with crafting
    @define permanentSelectedSlot m37 //8 bits
    @define health m41
    @define loadedTileEntity m42
    @define newestItemEntity m43
    @define itemEntities m44
    @define blockEntities m116
    @define endBlockEntities m224

//initial values
    str x 0x10
    str y 0x20
    str z 0x10
    str rot 0x00
    str onGround @max
    str velY 0
    str needReRender @max
    str crouching 0
    str prevX 0
    str prevY 0
    str prevZ 0
    str permanentSelectedSlot 0xFF // outside the inventory
    str health MAXHEALTH
    str newestItemEntity health //initialize to 3 cells before the start of the array, which happens to be where health is located.

lstr inventory 0 0x14
lstr inventory 1 0x55
lstr inventory 2 ITEM_IRONSHOVEL
lstr inventory 3 0xE2


.mainLoop
    out %playerinput r0 //synchronize playerInput device

    //handle inputs

        in r0 %playerinput //get input

        //handle miscellaneous inputs
            in r1 %playerinput //is open/close inventory pressed?
            bnz .bank2_loadInventoryGUI r1  //open inventory
            jmp ~+2
            
        .continueFromClosingInventory  // if inventory closed, continue from here
            str needReRender @max

            in r1 %playerinput //inventory movement
            lod r2 inventorySlot
            addv r2 r2 r1
            bne ~+2 r2 5  // rollover to left side of hotbar
                imm r2 0
            bne ~+2 r2 15  // rollover to right side of hotbar
                imm r2 4
            and r2 r2 0x0F  //keep within hotbar
            str inventorySlot r2
        
        //handle break/place
            cal .rayCast
                //r1: x, z pos of space before first found block
                //r2: y pos of space before first found block
                //r3: x, z pos of first found block
                //r4: y pos of first found block
                //r5: id of first found block (returns air if nothing found, bedrock will return -1)
                //r6: length of raycast (returns -1 if nothing found)
            in r7 %playerinput //r7 = is break pressed?
            brz .noRayCastHit r5
            brz .endBreakBlock r7
                brn .endBreakBlock r5 //if bedrock, can't break block
                bre .endBlockBreakAnim r5 BLOCK_SAPLING //break block instantly if it's a sapling
                //add block-breaking animation
                    cal .getRayCastTargetQuad
                    //stack:
                        //vert4x sp+15
                        //vert3x sp+14
                        //vert2x sp+13
                        //vert1x sp+12
                        //vert4y sp+11
                        //vert3y sp+10
                        //vert2y sp+9
                        //vert1y sp+8
                        //vert4z sp+7
                        //vert3z sp+6
                        //vert2z sp+5
                        //vert1z sp+4
                        //vert4uv sp+3
                        //vert3uv sp+2
                        //vert2uv sp+1
                        //vert1uv sp+0
                    //check what item is in hand to get the appropriate strength
                        lod r6 inventorySlot //r6 = item in hand
                        add r6 inventory r6
                        lod r6 r6
                        brl .breakWithoutTool r6 ITEM_NONSTACKABLE
                        brg .breakWithoutTool r6 ITEM_SHEARS
                        bre .breakWithShears r6 ITEM_SHEARS
                        and r7 r6 0x03
                        bsr r6 r6 2
                        and r6 r6 0b11 //r6 = tool tier
                        add r6 r6 STRENGTH_WOOD //r6 = tool strength
                        brz .breakWithPickaxe r7 //TOOL_PICKAXE
                        bre .breakWithAxe r7 TOOL_AXE
                        bre .breakWithShovel r7 TOOL_SHOVEL
                        jmp .breakWithoutTool
                        .breakWithShears
                            bne .breakWithoutTool r5 BLOCK_LEAVES
                            imm r6 STRENGTH_IRON //r6 = tool strength
                            jmp .endGetBreakStrength
                        .breakWithPickaxe
                            cal .getBlockType //r7 = blockType
                            bne .breakWithoutTool r7 BLOCKTYPE_STONE
                            jmp .endGetBreakStrength
                        .breakWithAxe
                            cal .getBlockType //r7 = blockType
                            bne .breakWithoutTool r7 BLOCKTYPE_WOOD
                            jmp .endGetBreakStrength
                        .breakWithShovel
                            cal .getBlockType //r7 = blockType
                            bne .breakWithoutTool r7 BLOCKTYPE_SOFT
                            jmp .endGetBreakStrength
                        .breakWithoutTool
                            imm r6 STRENGTH_FIST //r6 = tool strength
                        .endGetBreakStrength
                            cal .getBlockHardness
                            sub r7 r6 r7 //r7 = break strength
                    imm r6 TEXTURE_HIGHLIGHT0
                    .blockBreakAnimLoop
                        inc r6 r6
                        cal .buildQuadFromStack
                        out %amogus_settings 0b1101
                        out %amogus_tex r6
                        in r0 %amogus_drawquad
                        imm r2 0
                        .blockBreakAnimDelayLoop //this loop lasts shorter the higher breakstrength is
                            add r2 r2 r7
                            out %wait 50 //replace this code on CHUNGUS with any slow code. r1 should currently be free
                            in r0 %wait 
                        ble .blockBreakAnimDelayLoop r2 BREAKTIME
                        in r0 %amogus_drawtoscreen
                        //NOTE: if r1 gets used above, push it to the stack here
                        psh r2
                        psh r3
                        psh r4
                        psh r5
                        psh r6
                        psh r7
                            cal .drawHotbar
                        pop r7
                        pop r6
                        pop r5
                        pop r4
                        pop r3
                        pop r2
                        //NOTE: if r1 gets used above, pop it from the stack here
                        in r0 %screen_buffer
                    ble .blockBreakAnimLoop r6 TEXTURE_HIGHLIGHT7
                    imm sp BOTTOMOFSTACK //refresh stack after using .getRayCastTargetQuad
                .endBlockBreakAnim
                    brl .endDropItem r7 STRENGTHFORITEM //if break strength is insufficient don't drop an item
                    bre .endDropItem r5 BLOCK_GLASS
                    bne ~+4 r5 BLOCK_GRASS
                        imm r5 ENTITY_DIRT
                        cal .createEntity
                        jmp .endDropItem
                    bne ~+4 r5 BLOCK_STONE
                        imm r5 ENTITY_COBBLE
                        cal .createEntity
                        jmp .endDropItem
                    bre .breakLeavesDropItem r5 BLOCK_LEAVES
                    //default
                        cal .createEntity
                        jmp .endDropItem
                    .breakLeavesDropItem
                        bne ~+3 r7 STRENGTH_IRON //if using shears, drop leaves item
                            //r5 is already leaves entity ID
                            cal .createEntity
                            jmp .endDropItem
                        in r1 %rng
                        bge ~+4 r1 50 // 50/256 chance of dropping sapling
                            imm r5 ENTITY_SAPLING
                            cal .createEntity
                            jmp .endDropItem
                        bge ~+4 r1 70 // 20/256 chance of dropping stick
                            imm r5 ENTITY_STICK
                            cal .createEntity
                            jmp .endDropItem
                        brg ~+3 r1 80 // 10/256 chance of dropping apple
                            imm r5 ENTITY_APPLE
                            cal .createEntity
                    //jmp .endDropItem
                .endDropItem
                bsr r7 r3 4
                out %blockram_x r7
                and r7 r3 0x0f
                out %blockram_z r7
                out %blockram_y r4
                out %blockram_id 0 //replace targeted block with air
                //check if block above this block is sand or sapling, if so, make it fall
                .FallingSandLoop
                    inc r4 r4
                    out %blockram_y r4
                    in r5 %blockram_id
                    bne ~+5 r5 BLOCK_SAND
                        imm r5 ENTITY_FALLINGSAND
                        cal .createEntity
                        out %blockram_id 0
                        jmp .FallingSandLoop
                    bne ~+3 r5 BLOCK_SAPLING
                        cal .createEntity
                        jmp .FallingSandLoop
                str needReRender @max
                in r0 %playerinput //keep playerInput device synced
                jmp .endBreakAndPlace
            .endBreakBlock
            in r7 %playerinput //is place pressed?
            brz .endBreakAndPlace r7
                lod r7 crouching
                brl .endUseTargetedBlock r5 BLOCK_TABLE //check if targeted block is usable, if so, use it
                    //TODO: use targeted block
                        //search through blockEntity array until match is found
                        //set loadedBlockEntity pointer towards that block
                        //jump to appropriate location in bank2
                .endUseTargetedBlock
                lod r6 inventorySlot
                add r6 inventory r6
                lod r6 r6 //r6 = item in hand
                //check if item in hand is placeable, if not, jump to .useNonPlaceable
                    bge ~+6 r6 ITEM_TABLE //if nonstackable placeable, jump 6 lines 
                    bge .useNonPlaceable r6 ITEM_IRONINGOT
                    brz .useNonPlaceable r6
                    bre .useNonPlaceable r6 ITEM_COAL
                //get ID of block to place
                    bsr r6 r6 4
                    jmp ~+2
                        and r6 r6 0x0f //jump here if item was nonstackable placable
                //prepare block RAM                
                    bsr r7 r1 4
                    out %blockram_x r7
                    out %blockram_y r2
                    and r7 r1 0x0f
                    out %blockram_z r7
                bne .endCheckIfCanPlaceSapling r6 BLOCK_SAPLING //if placing sapling, check if it can be placed at the targted location
                    dec r3 r2
                    out %blockram_y r3
                    in r3 %blockram_id

                    brg .endBreakAndPlace r3 BLOCK_DIRT
                    brl .endBreakAndPlace r3 BLOCK_GRASS
                    out %blockram_y r2
                    jmp .placeBlock
                .endCheckIfCanPlaceSapling

                //check if targeted space intersects player
                    lod r3 x //r3 = player min x
                    and r4 r1 0xf0 //r4 = block min x
                    add r5 r4 0x10 //r5 = block max x
                    bge .endCheckIfIntersectPlayer r3 r5
                    add r3 r3 PLAYERWIDTH //player max x
                    ble .endCheckIfIntersectPlayer r3 r4

                    lod r3 y //r3 = player min y
                    bsl r4 r2 4 //r4 = block min y
                    add r5 r4 0x10 //r5 = block max y
                    bge .endCheckIfIntersectPlayer r3 r5
                    add r3 r3 PLAYERWIDTH //player max y
                    ble .endCheckIfIntersectPlayer r3 r4

                    lod r3 z //r3 = player min z
                    bsl r4 r1 4 //r4 = block min z
                    add r5 r4 0x10 //r5 = block max z
                    bge .endCheckIfIntersectPlayer r3 r5
                    add r3 r3 PLAYERWIDTH //player max z
                    ble .endCheckIfIntersectPlayer r3 r4
                    jmp .endBreakAndPlace
                .endCheckIfIntersectPlayer
                
                bne .placeBlock r6 BLOCK_SAND
                    dec r3 r2
                    out %blockram_y r3
                    in r3 %blockram_id
                    bnz .placeBlock r3
                    mov r3 r1
                    mov r4 r2
                    imm r5 ENTITY_FALLINGSAND
                    cal .createEntity
                    jmp .removeItemFromInventory
                .placeBlock
                    out %blockram_id r6
                    .removeItemFromInventory
                        lod r1 inventorySlot
                        add r1 inventory r1
                        lod r2 r1
                        brl ~+4 r2 0xf0
                            str r1 0
                            str needReRender @max
                            jmp .endBreakAndPlace
                        dec r2 r2
                        and r3 r2 0x0f
                        brz ~-5 r3
                        str r1 r2
                    str needReRender @max
            jmp .endBreakAndPlace
            .noRayCastHit
                in r7 %playerinput //is place pressed?
                brz .endBreakAndPlace r7
            .useNonPlaceable
                lod r1 inventorySlot
                add r1 inventory r1
                lod r2 r1
                and r3 r2 0xF0
                bne .endBreakAndPlace r3 ITEM_APPLE
                    //increase health
                        lod r3 health
                        add r3 r3 APPLEHEALTH
                        ble ~+2 r3 MAXHEALTH
                            imm r3 MAXHEALTH
                        str health r3
                    //decrease size of apple stack by 1
                        subv r2 r2 0x01
                        brg ~+2 r2 ITEM_APPLE
                            imm r2 0
                        str r1 r2

        .endBreakAndPlace

        //handle crouching inputs
            in r1 %playerinput //is crouch pressed?
            lod r2 crouching
            bre ~+3 r1 r2 //if crouching status changed:
                str crouching r1
                str needReRender r1

        //handle rotation inputs //TODO: add a limit on camera pitch
            in r1 %playerinput //rotation
            brz ~+5 r1
                lod r2 rot
                addv r2 r1 r2
                str rot r2
                str needReRender r1

        //handle movement inputs
            in r1 %playerinput //forward movement
            smlt446 r1 r1 SPEEDFACTOR //NOTE: this can be removed to save a few cycles and lose speed customizability
            
            in r2 %amogus_sinyaw
            neg r3 r2
            smlt446 r4 r1 r3 //r3 = velX

            in r3 %amogus_cosyaw
            smlt446 r5 r1 r3 //r4 = velZ
        
        
            in r1 %playerinput //strafe movement
            smlt446 r1 r1 SPEEDFACTOR //NOTE: this can be removed to save a few cycles and lose speed customizability

            smlt446 r6 r1 r2
            add r5 r5 r6 //r5 = velZ

            smlt446 r6 r1 r3
            add r4 r4 r6 //r4 = velX
        
        //handle jumping inputs
            lod r1 onGround
            str onGround 0
            brz .jumpInputNoJump r1
            in r1 %playerinput //is jump pressed?
            brz .jumpInputNoJump r1
            //jump
                imm r1 JUMPSTRENGTH
                str velY r1
                jmp .jumpInputEnd
            .jumpInputNoJump
                lod r1 velY
                sub r1 r1 GRAVITY
                str velY r1
            .jumpInputEnd
        
        //move and collide
            in r0 %blockram_oobactive //tell the blockRAM to return blocks out of bounds
            //prepare stack
                psh r1 //velY
                psh r5 //velZ
                psh r4 //velX //sp+15
                psh %blockram_z
                psh %blockram_x
                psh %blockram_y //sp+12
                psh %blockram_z //sp+11
                psh %blockram_x //sp+10
                psh PLAYERWIDTH
                psh PLAYERWIDTH
                psh PLAYERHEIGHT //sp+7
                psh PLAYERWIDTH //sp+6
                psh PLAYERWIDTH //sp+5
                psh z
                psh x
                psh y //sp+2
                psh z //sp+1
                psh x //sp+0

            .collisionLoop //collide with blocks
                llod r3 sp 0 //r3 = memory location of pos in main axis
                lod r2 r3 //r2 = min pos in main axis before movement
                llod r4 sp 15 //r4 = get velocity in main axis
                add r1 r2 r4 //r1 = min pos in main axis after movement
                str r3 r1 //store position after movement in case no collision detected
                brn ~+4 r4 //if velocity negative, use (-) side of player to collide. Otherwise use (+) side
                    llod r5 sp 5 //r5 = player size in main axis
                    add r1 r1 r5 //r1 = max pos in main axis after movement
                    add r2 r2 r5 //r2 = max pos in main axis before movement
                bsr r2 r2 4 //r2 = block pos in main axis before movement
                bsr r1 r1 4 //r1 = block pos in main axis after movement
                bne ~+3 r2 r1 //if block position doesn't change, don't check collisions in this axis
                    pop r0
                    jmp .collideNoMovement
                bne ~+5 r3 y //only clamp position on the Y axis
                    ble ~+2 r1 BLOCKMIDDLEOFVOID //if min pos is greater than middle of void, it is negative, and should be clamped to 0.
                        imm r1 0
                    ble ~+2 r2 BLOCKMIDDLEOFVOID //if max pos is greater than middle of void, it is negative, and should be clamped to 0.
                        imm r2 0
                //r1 = min block pos in main axis
                //r2 = max block pos in main axis //HACK: having pre-movement position always be max is a bit hacky, but it works for this specific use case with these specific values of max speed in each axis, hitbox size, and gravity. If it ends up being smaller than the min pos, it'll just skip it when it reaches the end of the loop.
                llod r3 sp 1 //r3 = memory location of pos in secondary axis
                lod r3 r3 //r3 = min pos in secondary axis
                llod r4 sp 6 //r4 = player size in secondary axis
                add r4 r3 r4 //r4 = max pos in secondary axis
                bsr r3 r3 4 //r3 = min block pos in secondary axis
                bsr r4 r4 4 //r4 = max block pos in secondary axis
                llod r5 sp 2 //r5 = memory location of pos in tertiary axis
                lod r5 r5 //r5 = min pos in tertiary axis
                llod r6 sp 7 //r6 = player size in tertiary axis
                add r6 r5 r6 //r6 = max pos in tertiary axis
                bsr r5 r5 4 //r5 = min block pos in tertiary axis
                bsr r6 r6 4 //r6 = max block pos in tertiary axis
                psh r5 //min block pos in tertiary axis //NOTE: because more things are being added to stack, the indices from the "prepare stack" section above must be increased by 2 in the following code
                psh r3 //min block pos in secondary axis
                .collideMainAxisLoop
                    llod r7 sp 12 //r7 = port address of main axis output
                    out r7 r1 //send main axis position to blockRAM
                    llod r3 sp 0 //r3 = min block pos in secondary axis
                    .collideSecondaryAxisLoop
                        llod r7 sp 13 //r7 = port address of secondary axis output
                        out r7 r3 //send secondary axis position to blockRAM
                        llod r5 sp 1 //r5 = min block pos in tertiary axis
                        .collideTertiaryAxisLoop
                            llod r7 sp 14 //r7 = port address of tertiary axis output
                            out r7 r5 //send tertiary axis position to blockRAM
                            in r7 %blockram_id //r7 = id of block at this position
                            brz .collideNoCollision r7 //if air, no collision detected
                            bre .collideNoCollision r7 BLOCK_SAPLING //if sapling, no collision detected
                            //collsion detected
                                llod r7 sp 17 //r7 = velocity in main axis
                                brp .collideResolveNegative r7
                                .collideResolvePositive //if velocity is (-), resolve collision in (+) direction
                                    psh r1 //NOTE: must increase stack indices by 1 because another item has been added to stack
                                        bsl r7 r1 4 //r7 = world position of block in main axis
                                        add r7 r7 BLOCKSIZE //r7 = world position of player in main axis
                                        llod r1 sp 3 //r7 = pointer towards player position in main axis
                                        str r1 r7 //store player position
                                        mov r7 r1
                                    pop r1
                                    bne .collideResolveEnd r7 y //if main axis is y axis and collision detected in negative direction, player is on ground
                                    //do fall damage
                                            lod r3 velY
                                            neg r3 r3
                                            sub r3 r3 MINFALLDAMAGESPEED
                                            brn .endFallDamage r3
                                                smlt446 r3 r3 FALLDAMAGESCALING
                                                psh r2
                                                    lod r2 health
                                                    sub r2 r2 r3
                                                    brn .gameOver r2
                                                    brz .gameOver r2
                                                    str health r2
                                                pop r2
                                        .endFallDamage
                                        str onGround @max
                                        str velY 0
                                        jmp .collideResolveEnd
                                .collideResolveNegative //if velocity is (+), resolve collision in (-) direction
                                    psh r1 //NOTE: must increase stack indices by 1 because another item has been added to stack
                                        bsl r1 r1 4 //r7 = world position of block in main axis
                                        llod r7 sp 8 //r7 = player size in main axis
                                        inc r7 r7 //r7 = full player size in main axis
                                        sub r7 r1 r7 //r7 = player pos in main axis
                                        llod r1 sp 3 //r1 = RAM pos of main axis position
                                        str r1 r7 //store player position
                                        mov r7 r1
                                    pop r1
                                    bne .collideResolveEnd r7 y //if main axis is y axis and collision detected cancel vertical velocity
                                        str velY 0
                                        jmp .collideResolveEnd
                            .collideNoCollision
                            inc r5 r5 //r5 = teriary axis block pos
                        ble .collideTertiaryAxisLoop r5 r6 //if teriary axis position is <= max tertiary position, do another loop
                        inc r3 r3 //r3 = secondary axis block pos
                    ble .collideSecondaryAxisLoop r3 r4 //if secondary axis position is <= max secondary position, do another loop
                    .collideResolveEnd //if a collision is detected, we don't need to check the other secondary and tertiary axis positions at this main axis position
                    inc r1 r1
                brl .collideMainAxisLoop r1 r2 //if main axis position is < max main position (-1, technically, which is why we use < instead of <=), do another loop
                add sp sp 3 //or pop 3 times
                .collideNoMovement //if no movement was detected in the main axis, skip to here.
                llod r7 sp 0
            bne .collisionLoop r7 x //if next loop starts on X axis, don't do another loop. Always loops 2 times.
            imm sp BOTTOMOFSTACK //reset the stack //NOTE: If the size of the stack before collision detection occurs changes, this value must also change.

            //collide with bedrock
                lod r1 y
                ble .endCollideWithBedrock r1 MIDDLEOFVOID
                    str y 0
                    //do fall damage
                        lod r1 velY
                        neg r1 r1
                        sub r1 r1 MINFALLDAMAGESPEED
                        brn .endFallDamageBedrock r1
                            smlt446 r1 r1 FALLDAMAGESCALING
                            psh r2
                                lod r2 health
                                sub r2 r2 r1
                                brn .gameOver r2
                                brz .gameOver r2
                                str health r2
                            pop r2
                    .endFallDamageBedrock
                    
                    str onGround @max
                    str velY 0
            .endCollideWithBedrock
        
        in r0 %playerinput //is delete item pressed?
    
    //TODO: suffocation
        //if player head in block:
            //run suffocation animation
            //go to death screen
    
    //update all items
        //NOTE: entity format is as follows:
            //byte 1: VVVV_IIII; V=y-velocity, I=id
            //byte 2: XXX.X_ZZZ.Z
            //byte 3: 0YYY.YYYY
        imm r1 itemEntities
        .updateItemEntitiesLoop //loop through all items
            lod r2 r1
            brz .updateItemEntitiesNext r2
                
                //if near player and is not falling sand:
                    and r3 r2 0x0f
                    bre .endPickUpItem r3 ENTITY_FALLINGSAND

                    inc r3 r1
                    lod r3 r3
                    and r4 r3 0xF0
                    rsh r4 r4 //r4 = item x pos
                    
                    lod r5 x
                    sub r6 r5 PICKUPSIDENEG //r6 = min item x pos for pickup
                    ble ~+2 r6 MIDDLEOFVOID
                        imm r6 0
                    brl .endPickUpItem r4 r6

                    add r6 r5 PICKUPSIDEPOS //r6 = max item x pos for pickup
                    brg .endPickUpItem r4 r6

                    and r4 r3 0x0F
                    bsl r4 r4 3 //r4 = item z pos

                    lod r5 z
                    sub r6 r5 PICKUPSIDENEG //r6 = min item z pos for pickup
                    ble ~+2 r6 MIDDLEOFVOID
                        imm r6 0
                    brl .endPickUpItem r4 r6

                    add r6 r5 PICKUPSIDEPOS //r6 = max item z pos for pickup
                    brg .endPickUpItem r4 r6

                    add r3 r1 2
                    lod r4 r3 //r4 = item y pos

                    lod r5 y
                    sub r6 r5 PICKUPDOWN //r6 = min item y pos for pickup
                    ble ~+2 r6 MIDDLEOFVOID
                        imm r6 0
                    brl .endPickUpItem r4 r6

                    add r6 r5 PICKUPSIDEPOS //r6 = max item y pos for pickup
                    brg .endPickUpItem r4 r6

                    //convert item entity to inventory item and store in r7 for function call
                        and r3 r2 0x0F //r3 = entity id
                        bne ~+3 r3 ENTITY_APPLE
                            imm r7 0xE1
                            jmp .endConvertEntityToItem
                        bne ~+3 r3 ENTITY_TABLE
                            imm r7 ITEM_TABLE
                            jmp .endConvertEntityToItem
                        bne ~+3 r3 ENTITY_FURNACE
                            imm r7 ITEM_FURNACE
                            jmp .endConvertEntityToItem
                        bne ~+3 r3 ENTITY_CHEST
                            imm r7 ITEM_CHEST 
                            jmp .endConvertEntityToItem
                        //entity item has same ID as inventory item:
                            bsl r7 r3 4
                            inc r7 r7
                    .endConvertEntityToItem
                    psh r1 //preserve r1 through function call
                        cal .bank1_addItemToInventory
                    pop r1
                    str r1 0 //delete item entity
                .endPickUpItem
                //apply gravity
                    lod r2 r1
                    bge ~+2 r2 0xF0
                        addv r2 r2 0x10
                    str r1 r2

                    and r2 r2 0xF0
                    add r3 r1 2
                    lod r3 r3 
                    sub r6 r3 r2
                    bge ~+2 r6 MIDDLEOFVOID
                        imm r6 0
                    
                    bsr r3 r3 4 //r3 = start pos
                    bsr r4 r6 4 //r4 = end pos
                    
                    inc r2 r1
                    lod r2 r2
                    bsr r5 r2 5
                    out %blockram_x r5

                    and r5 r2 0x0F
                    rsh r5 r5
                    out %blockram_z r5

                    .itemEntityCollisionLoop1
                        out %blockram_y r3
                        in r2 %blockram_id
                        bge .itemEntityResolveCollisionLoop r3 BLOCKMIDDLEOFVOID
                        brz .itemEntityCollisionLoop1Next r2
                        bre .itemEntityCollisionLoop1Next r2 BLOCK_SAPLING
                        .itemEntityResolveCollisionLoop
                            inc r3 r3
                            out %blockram_y r3
                            in r5 %blockram_id
                            bge .itemEntityResolveCollision r3 8
                            brz .itemEntityResolveCollision r5
                            bne .itemEntityResolveCollisionLoop r5 BLOCK_SAPLING
                            .itemEntityResolveCollision
                                lod r2 r1
                                and r4 r2 0x0F
                                bne .itemEntityResolveCollisionNotFallingSand r4 ENTITY_FALLINGSAND
                                    bne .convertFallingSandToBlock r5 BLOCK_SAPLING
                                        dec r2 r2 //convert falling sand entity into sand entity
                                        str r1 r2
                                        inc r2 r1
                                        lod r4 r2 //randomize x and z position of entity
                                        in r5 %rng
                                        and r5 r5 0x11
                                        or r4 r4 r5
                                        str r2 r4
                                        jmp .itemEntityResolveCollisionNotFallingSand
                                    .convertFallingSandToBlock
                                        out %blockram_id BLOCK_SAND
                                        str r1 0
                                        jmp .updateItemEntitiesNext
                                .itemEntityResolveCollisionNotFallingSand
                                bsl r3 r3 4
                                add r2 r1 2
                                str r2 r3
                                lod r2 r1
                                and r2 r2 0x0F //reset velocity of item after collision
                                str r1 r2
                                jmp .updateItemEntitiesNext
                        .itemEntityCollisionLoop1Next
                        dec r3 r3
                    bge .itemEntityCollisionLoop1 r3 r4
                    add r2 r1 2
                    str r2 r6
            .updateItemEntitiesNext
            add r1 r1 3
        brl .updateItemEntitiesLoop r1 blockEntities

    //TODO: update all furnaces
        //loop through all block entities
            //if furnace
                //progress timers
                //apply recipe

    //do rendering stuff
        //check if full render is necessary
            lod r1 needReRender
            bnz .doFullRender r1

            //check if player moved
                lod r1 prevX
                lod r2 x
                str prevX r2
                bne .doFullRender r1 r2

                lod r1 prevY
                lod r2 y
                str prevY r2
                bne .doFullRender r1 r2

                lod r1 prevZ
                lod r2 z
                str prevZ r2
                bne .doFullRender r1 r2
            
        //if full render not necessary:
            imm r1 50 //TEMP: this simulates a faster frame when you don't need to simulate the entire sccene.
            cal .drawEnties //always draw entities
        jmp .renderUI

        .doFullRender
            in r0 %amogus_clearbuffer

            lod r1 rot
            out %amogus_camrot r1

            lod r1 x
            add r1 r1 PLAYERHALFWIDTH //move from corner of player to middle
            out %amogus_camx r1

            lod r1 z
            add r1 r1 PLAYERHALFWIDTH //move from corner of player to middle
            out %amogus_camz r1

            lod r1 y
            imm r2 PLAYERCAMHEIGHT
            lod r3 crouching
            brz ~+2 r3
                imm r2 PLAYERCROUCHCAMHEIGHT
            add r1 r1 r2 //move to appropriate camera height
            out %amogus_camy r1
        
            in r0 %meshgen_renderscene

            //TODO: render chest and furnace faces

            //render target highlight
                cal .rayCast
                brz ~+7 r5 //if raycast hits nothing, don't render a highlight
                    cal .getRayCastTargetQuad
                    cal .buildQuadFromStack
                    out %amogus_settings 0b1101
                    out %amogus_tex TEXTURE_HIGHLIGHT0
                    in r0 %amogus_drawquad
                    imm sp BOTTOMOFSTACK //refresh stack after using .getRayCastTargetQuad
            
            cal .drawEnties

            in r0 %amogus_drawtoscreen
            imm r1 @max //TEMP: this simulates the lag from drawing the entire screen in-game
        .renderUI
            out %wait r1 //TEMP: r1 is set based on what type of frame was drawn. Full-render frames are much slower.
            in r0 %wait
            cal .drawHotbar
                

    //do end of frame cleanup + wait for next frame
        in r0 %screen_buffer
        str needReRender 0
jmp .mainLoop

.gameOver
    in r0 %screen_clearscreen
    //TODO: draw 'game over' message to screen
    //TODO: respawning
    in r0 %screen_buffer
hlt

//createEntity function: creates a new item entity based on a location and an entity ID
    //inputs:
        //r3: X, Z block position of entity //NOTE: preserved
        //r4: Y block position of entity //NOTE: preserved
        //r5: ID of entity
    //outputs:
        //none
    //NOTE: entity format is as follows:
        //byte 1: VVVV_IIII; V=y-velocity, I=id
        //byte 2: XXX.X_ZZZ.Z
        //byte 3: 0YYY.YYYY
.createEntity
    lod r1 newestItemEntity
    add r1 r1 3
    brl ~+2 r1 blockEntities
        imm r1 itemEntities
    str newestItemEntity r1
    str r1 r5
    inc r1 r1
    lsh r2 r3
    bne ~+3 r5 ENTITY_FALLINGSAND
        imm r5 0 //if entity is falling sand, don't randomize position.
    jmp ~+2
        in r5 %rng
    and r6 r5 0x11
    or r2 r2 r6
    str r1 r2
    inc r1 r1
    bsl r2 r4 4
    rsh r5 r5
    and r6 r5 0x07
    or r2 r2 r6
    str r1 r2
ret

//getBlockType function: returns the type of block based on a block ID
    //inputs:
        //r5: block ID
    //outputs:
        //r7: block type
.getBlockType
    //stone blocks: stone, cobble, iron ore, coal ore, furnace
        bre ~+5 r5 BLOCK_STONE
        bre ~+4 r5 BLOCK_COBBLE
        bre ~+3 r5 BLOCK_IRONORE
        bre ~+2 r5 BLOCK_COALORE
        bne ~+3 r5 BLOCK_FURNACE
            imm r7 BLOCKTYPE_STONE
            ret
    //wood blocks: plank, log, crafting table, chest
        bre ~+4 r5 BLOCK_PLANK
        bre ~+3 r5 BLOCK_LOG
        bre ~+2 r5 BLOCK_TABLE
        bne ~+3 r5 BLOCK_CHEST
            imm r7 BLOCKTYPE_WOOD
            ret
    //soft blocks: sand, dirt, grass
        bre ~+3 r5 BLOCK_SAND
        bre ~+2 r5 BLOCK_DIRT
        bne ~+3 r5 BLOCK_GRASS
            imm r7 BLOCKTYPE_SOFT
            ret
    //leaves: leaves
        bne ~+3 r5 BLOCK_LEAVES
            imm r7 BLOCKTYPE_LEAVES
            ret
    //glass: glass
        bne ~+3 r5 BLOCK_GLASS
            imm r7 BLOCKTYPE_GLASS
            ret
    //sapling: sapling
        imm r7 BLOCKTYPE_SAPLING
ret

//getBlockHardness function: returns the hardness of a block based on block ID
    //inputs:
        //r5: block ID
    //outputs:
        //r7: block hardness
.getBlockHardness
    //N/A: sapling
    //hardness 0: leaves, sand, dirt, grass
        bre ~+4 r5 BLOCK_LEAVES
        bre ~+3 r5 BLOCK_SAND
        bre ~+2 r5 BLOCK_DIRT
        bne ~+3 r5 BLOCK_GRASS
            imm r7 0
            ret
    //hardness 1: log, plank, table, chest, glass
        bre ~+5 r5 BLOCK_GLASS
        bre ~+4 r5 BLOCK_PLANK
        bre ~+3 r5 BLOCK_LOG
        bre ~+2 r5 BLOCK_TABLE
        bne ~+3 r5 BLOCK_CHEST
            imm r7 1
            ret
    //hardness 2: stone, cobble, furnace, coal ore
        bre ~+4 r5 BLOCK_STONE
        bre ~+3 r5 BLOCK_COBBLE
        bre ~+2 r5 BLOCK_COALORE
        bne ~+3 r5 BLOCK_FURNACE
            imm r7 2
            ret
    //hardness 3: iron ore
        imm r7 3
ret

 

.drawHotbar
    // draw highlight (black rectangle around hotbar)
    out %screen_x1 19  // top left x
    out %screen_y1 51  // top left y
    out %screen_x2 76  // bottom right x
    out %screen_y2_clearrect 63  // bottom right y
    // draw borders
    out %screen_x1 20  // top left x
    out %screen_y1 52  // top left y
    out %screen_x2 75  // bottom right x
    out %screen_y2_drawrect 63  // bottom right y
    // draw items
    imm r1 21  // top left x
    imm r2 53  // top left y
    imm r5 5  // length of hotbar
    imm r6 inventory  // load memory address of hotbar items
    lod r7 inventorySlot  // get selected item
    cal .drawGUIRow
    //draw hearts
    out %screen_y1 43
    imm r1 19
    .drawEmptyHeartsLoop
        out %screen_x1 r1
        out %screen_texid_drawinvtex TEXTURE_HEARTEMPTY
        add r1 r1 6
    ble .drawEmptyHeartsLoop r1 61
    imm r1 19
    imm r2 1
    lod r3 health
    .drawFullHeartsLoop
        out %screen_x1 r1
        out %screen_texid_drawtex TEXTURE_HEARTFULL
        add r1 r1 6
        inc r2 r2
    ble .drawFullHeartsLoop r2 r3

ret

.drawEnties
    imm r1 itemEntities
    .renderItemEntitiesLoop
        lod r2 r1
        brz .renderItemEntitiesNext r2
            and r2 r2 0x0f
            out %meshgen_itemid r2

            add r2 r1 1
            lod r2 r2
            out %meshgen_itemxz r2

            add r2 r1 2
            lod r2 r2
            out %meshgen_itemy r2
            in r0 %meshgen_renderitem
        .renderItemEntitiesNext
        add r1 r1 3
    brl .renderItemEntitiesLoop r1 blockEntities
ret


//rayCast function //OPTIM: there is still a lot of room for optimization in this section of code. Most of it can probably be reused instead of repeated.
    //description:
        //casts a ray from the position and direction of the camera, and returns what it hits
    //inputs:
        // x memory location
        // y memory location
        // z memory location
        // some ports
        // some constants
    //outputs:
        //r1: x, z pos of space before first found block
        //r2: y pos of space before first found block
        //r3: x, z pos of first found block
        //r4: y pos of first found block
        //r5: id of first found block (returns air if nothing found, bedrock will return -1)
        //r6: length of raycast (returns -1 if nothing found)
    //storage used:
        //r1 - r7 (not preserved)
        //4 stack positions
.rayCast
    in r0 %blockram_oobinactive //tell the blockram not to return blocks out of bounds

    //initialize values
    lod r1 x
    add r1 r1 PLAYERHALFWIDTH
    and r5 r1 0x0f //r5 = cam x pos in block
    bsr r1 r1 4 //r1 = x block pos

    lod r2 y
    add r2 r2 PLAYERCAMHEIGHT
    and r6 r2 0x0f //r6 = cam y pos in block
    bsr r2 r2 4 //r2 = y block pos

    lod r3 z
    add r3 r3 PLAYERHALFWIDTH
    and r7 r3 0x0f //r7 = cam z pos in block
    bsr r3 r3 4 //r3 = z block pos

    //OPTIM: convert the following repeated code segment into a loop?

    //set up initial X t values
        in r4 %amogus_camdirx
        brn ~+3 r4 //if camDirX positive:
            sub r5 BLOCKSIZE r5 //swap X distance to edge of block direction
            jmp ~+2
        //if camDirX negative:
            neg r4 r4
        sdiv446 r5 r5 r4 //r5 = tMaxX
        sdiv446 r4 0x10 r4 //r4 = tDeltaX
        ble ~+2 r4 RAYCASTMAXLENGTH
            imm r4 RAYCASTMAXLENGTH
        psh r4

    //set up initial Y t values
        in r4 %amogus_camdiry
        brn ~+3 r4 //if camDirY positive:
            sub r6 BLOCKSIZE r6 //swap X distance to edge of block direction
            jmp ~+2
        //if camDirY negative:
            neg r4 r4
        sdiv446 r6 r6 r4 //r6 = tMaxY
        sdiv446 r4 0x10 r4 //r4 = tDeltaY
        ble ~+2 r4 RAYCASTMAXLENGTH
            imm r4 RAYCASTMAXLENGTH
        psh r4

    //set up initial Z t values
        in r4 %amogus_camdirz
        brn ~+3 r4 //if camDirZ positive:
            sub r7 BLOCKSIZE r7 //swap X distance to edge of block direction
            jmp ~+2
        //if camDirZ negative:
            neg r4 r4
        sdiv446 r7 r7 r4 //r7 = tMaxZ
        sdiv446 r4 0x10 r4 //r4 = tDeltaZ
        ble ~+2 r4 RAYCASTMAXLENGTH
            imm r4 RAYCASTMAXLENGTH
        psh r4

    //stack:
        //sp+2: tDeltaX
        //sp+1: tDeltaY
        //sp+0: tDeltaZ
    //regs:
        //r1: x pos
        //r2: Y pos
        //r3: Z pos
        //r4: tDeltaZ
        //r5: x tMaxX
        //r6: y tMaxY
        //r7: z tMaxZ
    
    out %blockram_x r1
    out %blockram_y r2
    out %blockram_z r3
    
    bsl r1 r1 4
    or r3 r1 r3 //r3 = combined xz pos
    mov r4 r2 //r4 = y pos
    
    //OPTIM: make .rayCastFunctionStepX, Y, and Z all use the same code?

    .rayCastFunctionLoop
        //move currentBlock to previousBlock
        mov r1 r3
        mov r2 r4

        brg .rayCastFunctionDontStepX r5 r6 //if (tMaxX <= tMaxY) {rayCastFunctionDontStepX()}
            brg .rayCastFunctionStepZ r5 r7 //if (tMaxX <= tMaxZ) && (tMaxX <= tMaxY) {rayCastFunctionStepX()}
            
                .rayCastFunctionStepX

                    ble ~+4 r5 RAYCASTMAXLENGTH
                        imm r5 0
                        imm r6 -1 //raycast length = -1
                        jmp .rayCastFunctionEnd

                    psh r5 //free up r5 to use as a temp register
                        in r5 %amogus_camdirx
                        brn ~+3 r5 //if camDirX is positive:
                            addv r3 r3 0x10 //increment x
                        jmp ~+2 //if camDirX is negative:
                            subv r3 r3 0x10 //decrement x
                        bsr r5 r3 4
                        out %blockram_x r5

                        //fetch the new block
                            in r5 %blockram_id
                            brz ~+3 r5
                                pop r6 //raycast Length = tMaxX
                                jmp .rayCastFunctionEnd
                    pop r5
                    llod r1 sp 2 //r1 = tDeltaX
                    add r5 r5 r1 //tMaxX = tMaxX + dDeltaX

                jmp .rayCastFunctionLoop

                .rayCastFunctionStepZ

                    ble ~+4 r7 RAYCASTMAXLENGTH
                        imm r5 0
                        imm r6 -1 //raycast length = -1
                        jmp .rayCastFunctionEnd

                    psh r5 //free up r5 to use as a temp register
                        in r5 %amogus_camdirz
                        brn ~+3 r5 //if camDirZ is positive:
                            addv r3 r3 0x01 //increment z
                        jmp ~+2 //if camDirZ is negative:
                            subv r3 r3 0x01 //decrement z
                        and r5 r3 0x0f
                        out %blockram_z r5

                        //fetch the new block
                            in r5 %blockram_id
                            brz ~+4 r5
                                pop r0
                                mov r6 r7 //raycast length = tMaxZ
                                jmp .rayCastFunctionEnd
                    pop r5
                    llod r1 sp 0 //r1 = tDeltaZ
                    add r7 r7 r1 //tMaxZ = tMaxZ + dDeltaZ

                jmp .rayCastFunctionLoop

            .rayCastFunctionDontStepX
            brg .rayCastFunctionStepZ r6 r7

                .rayCastFunctionStepY
                    ble ~+4 r6 RAYCASTMAXLENGTH
                        imm r5 0
                        imm r6 -1 //raycast length = -1
                        jmp .rayCastFunctionEnd

                    psh r5 //free up r5 to use as a temp register
                        in r5 %amogus_camdiry
                        brn ~+3 r5 //if camDirY is positive:
                            inc r4 r4 //increment y
                        jmp ~+2 //if camDirY is negative:
                            dec r4 r4 //decrement y
                        out %blockram_y r4

                        //fetch the new block
                            bne ~+4 r4 -1 //check if y is at bedrock
                                pop r0
                                imm r5 -1 //return bedrock if y = -1
                                jmp .rayCastFunctionEnd
                            in r5 %blockram_id
                            brz ~+3 r5
                                pop r0
                                jmp .rayCastFunctionEnd
                    pop r5
                    llod r1 sp 1 //r1 = tDeltaY
                    add r6 r6 r1 //tMaxY = tMaxY + dDeltaY
                
                jmp .rayCastFunctionLoop
    .rayCastFunctionEnd
        pop r0
        pop r0
        pop r0
ret


.getRayCastTargetQuad 
    //get quad vertices //OPTIM: there is almost certainly a better way to do this
        brg .targetPosYQuad r2 r4
        brl .targetNegYQuad r2 r4
        and r6 r1 0xf0 //r6 = rayCastPrevX
        and r7 r3 0xf0 //r7 = rayCastcurrX
        brg .targetPosXQuad r6 r7
        brl .targetNegXQuad r6 r7
        and r6 r1 0x0f //r6 = rayCastPrevZ
        and r7 r3 0x0f //r7 = rayCastcurrZ
        brg .targetPosZQuad r6 r7
        //brl .targetNegXQuad r6 r7
        .targetNegZQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y
            
            add r6 r6 16
            psh r6 //vert4x
            psh r6 //vert3x
            sub r6 r6 16
            psh r6 //vert2x
            psh r6 //vert1x

            psh r7 //vert4z
            psh r7 //vert3z
            psh r7 //vert2z
            psh r7 //vert1z

            bsl r7 r4 4
            add r6 r7 16
            psh r7 //vert4y
            psh r6 //vert3y
            psh r6 //vert2y
            psh r7 //vert1y

            jmp .endGetQuad
        .targetPosZQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y

            psh r6 //vert4x
            psh r6 //vert3x
            add r6 r6 16
            psh r6 //vert2x
            psh r6 //vert1x

            add r6 r7 16
            psh r6 //vert4z
            psh r6 //vert3z
            psh r6 //vert2z
            psh r6 //vert1z

            bsl r7 r4 4
            add r6 r7 16
            psh r7 //vert4y
            psh r6 //vert3y
            psh r6 //vert2y
            psh r7 //vert1y

            jmp .endGetQuad
        .targetNegXQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y

            psh r6 //vert4x
            psh r6 //vert3x
            psh r6 //vert2x
            psh r6 //vert1x

            add r6 r7 16
            psh r7 //vert4z
            psh r7 //vert3z
            psh r6 //vert2z
            psh r6 //vert1z

            bsl r7 r4 4
            add r6 r7 16
            psh r7 //vert4y
            psh r6 //vert3y
            psh r6 //vert2y
            psh r7 //vert1y

            jmp .endGetQuad
        .targetPosXQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y
            add r6 r6 16
            psh r6 //vert4x
            psh r6 //vert3x
            psh r6 //vert2x
            psh r6 //vert1x

            add r6 r7 16
            psh r6 //vert4z
            psh r6 //vert3z
            psh r7 //vert2z
            psh r7 //vert1z

            bsl r7 r4 4
            add r6 r7 16
            psh r7 //vert4y
            psh r6 //vert3y
            psh r6 //vert2y
            psh r7 //vert1y

            jmp .endGetQuad
        .targetNegYQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y
            
            add r6 r6 16
            psh r6 //vert4x
            psh r6 //vert3x
            sub r6 r6 16
            psh r6 //vert2x
            psh r6 //vert1x

            add r6 r7 16
            psh r6 //vert4z
            psh r7 //vert3z
            psh r7 //vert2z
            psh r6 //vert1z

            bsl r7 r4 4
            psh r7 //vert4y
            psh r7 //vert3y
            psh r7 //vert2y
            psh r7 //vert1y

            jmp .endGetQuad
        .targetPosYQuad
            and r6 r3 0xf0 //r6 = X
            bsl r7 r3 4 //r7 = Z
            //r4 = Y
            
            add r6 r6 16
            psh r6 //vert4x
            psh r6 //vert3x
            sub r6 r6 16
            psh r6 //vert2x
            psh r6 //vert1x

            add r6 r7 16
            psh r7 //vert4z
            psh r6 //vert3z
            psh r6 //vert2z
            psh r7 //vert1z

            bsl r7 r4 4
            add r6 r7 16
            psh r6 //vert4y
            psh r6 //vert3y
            psh r6 //vert2y
            psh r6 //vert1y
        .endGetQuad
        psh 0x80 //vert4uv
        psh 0x88 //vert3uv
        psh 0x08 //vert2uv
        psh 0x00 //vert1uv
ret //NOTE: this only works with a callstack because of stack stuff

.buildQuadFromStack
    psh r0
    psh r0
    psh r0
    psh r0 //add 4 junk values to stack so we can safely pop them.
    imm r2 0
    .buildQuadFromStackLoop
        llod r1 sp 4
        out %amogus_vertuv r1
        llod r1 sp 8
        out %amogus_verty r1
        llod r1 sp 12
        out %amogus_vertz r1
        llod r1 sp 16 //NOTE: there are ways to decrease this number if it's too large
        out %amogus_vertx r1
        in r0 %amogus_submitvert
        inc r2 r2
        pop r0 //on CHUNGUS, this can be combined with the last LLOD instruction
    brl .buildQuadFromStackLoop r2 4 //loop exactly 4 times
ret


//drawItem function
    //description:
        // draws an item at given x,y
        // where x,y is the top left corner of area (1 top/left of the item itself)
    //inputs:
        // r1: x (preserved)
        // r2: y (preserved)
        // r3: item
        // r4: is item selected? (0 = selected, anything else = not selected)
    //outputs:
        // none
    //storage used:
        // none
.drawItem
    // draw first rectangle
    out %screen_x1 r1
    out %screen_y1 r2
    add r1 r1 9  // x2
    add r2 r2 9  // y2
    out %screen_x2 r1
    out %screen_y2 r2
    sub r1 r1 8  // adjust x, y to correct position to draw item itself
    sub r2 r2 8
    // check if rectangle needs to be filled or emptied
    bnz .drawItemNotSelected r4

        // draw selected outline
        in r0 %screen_drawrect
        out %screen_x1 r1  // load inner rectangle coordinates
        out %screen_y1 r2
        add r1 r1 7  // x2
        add r2 r2 7  // y2
        out %screen_x2 r1
        out %screen_y2 r2
        sub r1 r1 7  // adjust x, y back to correct position
        sub r2 r2 7

    .drawItemNotSelected
    in r0 %screen_clearrect  // clear inner rectangle
    bnz .drawItemNonZero r3  // check if item exists (ie. not 00000000)

        .drawItemReturn
        sub r1 r1 1  // preserve x,y
        sub r2 r2 1
        in r0 %screen_nop  // ensure screen queue cleared
        ret

    .drawItemNonZero
    out %screen_x1 r1  // load correct x1, y1
    out %screen_y1 r2
    bge .drawItemNonstackable r3 0xF0 // check if item is nonstackable
        // draw stackable item
        bsr r4 r3 4  // get item id
        add r4 r4 TEXTURE_STACKABLE  // draw item texture
        out %screen_texid_drawtex r4

        // draw item count
        and r3 r3 0x0F  // get item count
        add r3 r3 TEXTURE_NUMBER  // get background texture
        add r1 r1 2  // move x,y over to correct position
        add r2 r2 2
        out %screen_x1 r1  // draw background texture
        out %screen_y1 r2
        out %screen_texid_drawtex r3
        add r3 r3 0x10  // get number texture
        out %screen_texid_drawinvtex r3

        // return
        sub r1 r1 3  // preserve x,y
        sub r2 r2 3
        in r0 %screen_nop  // ensure screen queue cleared
        ret

    .drawItemNonstackable
        // draw nonstackable item
        and r3 r3 0x0F  // get item id
        add r3 r3 TEXTURE_NONSTACKABLE  // draw item texture
        out %screen_texid_drawtex r3
        jmp .drawItemReturn  // return
// end drawItem function


//drawGUIRow function
    //description:
        // draws a row of items of length r5 starting at x,y
        // pointed to by r6 in memory with r7 selected
    //inputs:
        // r1: x
        // r2: y
        // r5: length
        // r6: memory address of first item
        // r7: item in row selected (>length = none selected)
    //outputs:
        // none
    //storage used:
        // none
.drawGUIRow
    sub r7 r5 r7  // get loop index of selected item
    .drawGUIRowLoop
        lod r3 r6  // get item
        sub r4 r5 r7  // check if selected (r7 == r5)
        cal .drawItem  // draw item
        add r1 r1 11  // increase x by slot size
        add r6 r6 1  // increase memory index
        sub r5 r5 1  // decrease loop counter
        bnz .drawGUIRowLoop r5 // loop if not done yet
    ret  // return
// end drawGUIRow function

.bank1_addItemToInventory
    // input: r7 (item)
    // other registers not necessarily preserved
    imm r1 0
    and r6 r7 0xF0  // item id
    bre .bank1_skipStackLoop r6 0xF0  // skip if nonstackable
    .bank1_addItemToInventoryStackLoop
        add r1 r1 inventory  // check what item is already there
        lod r2 r1
        and r3 r2 0xF0
        bne .bank1_addItemToInventoryStackLoopContinue r3 r6  // ensure same item ID
            and r4 r2 0x0F  // get item counts
            and r5 r7 0x0F
            add r5 r4 r5  // get sum
            bge .bank1_addItemToInventoryStackStackTooBig r5 16  // skip if stack too big
                add r3 r3 r5
                str r1 r3  // store new, bigger stack
                ret  // done
            .bank1_addItemToInventoryStackStackTooBig
            or r2 r2 15
            str r1 r2  // store max size stack
            sub r5 r5 15  // remaining items
            add r7 r6 r5  // new item id
        .bank1_addItemToInventoryStackLoopContinue
        sub r1 r1 inventory
        add r1 r1 1  // continue and check if done
    brl .bank1_addItemToInventoryStackLoop r1 15
        
    .bank1_skipStackLoop
    imm r1 0
    .bank1_addItemToInventoryLoop
        add r1 r1 inventory  // check what item is already there
        lod r2 r1
        bnz ~+3 r2  // no item
            str r1 r7  // store regardless of what it is
            ret  // done
        bge .bank1_addItemToInventoryLoopContinue r7 0xF0  // skip if nonstackable
        and r3 r2 0xF0  // get item id
        bne .bank1_addItemToInventoryLoopContinue r6 r3  // skip if not same item id
            and r4 r2 0x0F  // get item counts
            and r5 r7 0x0F
            add r5 r4 r5  // get sum
            bge .bank1_addItemToInventoryStackTooBig r5 16  // skip if stack too big
                add r3 r3 r5
                str r1 r3  // store new, bigger stack
                ret  // done
            .bank1_addItemToInventoryStackTooBig
            or r2 r2 15
            str r1 r2  // store max size stack
            sub r5 r5 15  // remaining items
            add r7 r6 r5  // new item id
        .bank1_addItemToInventoryLoopContinue
        sub r1 r1 inventory
        add r1 r1 1  // continue and check if done
    brl .bank1_addItemToInventoryLoop r1 15
ret









// get slot x,y and memory address from id
.bank2_multiplyXAndYBy11
    add r7 r7 r5  // adjust memory address by x
    mlt r5 r5 11  // multiply
    mlt r6 r6 11
ret
.bank2_inventoryGetSlot
    // r5: x (returned)
    // r6: y (returned)
    // r7: slot, address (returned)
    // NOTE: for chests and furnaces (tile entitites), return address is relative within them
    bsr r6 r7 4  // split x and y
    and r5 r7 0x0F  // x

    bge ~+6 r7 0x10  // on hotbar
        imm r7 inventory  // memory address
        cal .bank2_multiplyXAndYBy11
        imm r6 53  // y
        add r5 r5 21  // x
        ret
    bge ~+7 r7 0x30  // within main inventory
        mlt r7 r6 5  // memory address
        add r7 r7 inventory
        cal .bank2_multiplyXAndYBy11
        sub r6 52 r6  // y
        add r5 r5 21  // x
        ret
    bge ~+12 r7 0x50  // within chest
        sub r6 r6 3
        mlt r7 r6 5  // memory address
        psh r1
        lod r1 loadedTileEntity
        add r7 r7 r1
        add r7 r7 2
        pop r1
        cal .bank2_multiplyXAndYBy11
        sub r6 18 r6  // y
        add r5 r5 21  // x
        ret
    bge ~+11 r7 0x70  // within small crafting grid
        sub r6 6 r6
        mlt r7 r6 3  // memory address
        sub r6 1 r6
        add r7 r7 craftingGrid
        add r7 r7 r5  // adjust memory address by x
        mlt r5 r5 9  // multiply
        mlt r6 r6 9
        sub r6 18 r6  // y
        add r5 r5 26  // x
        ret
    bge ~+11 r7 0xA0  // within large crafting grid
        sub r6 9 r6
        mlt r7 r6 3  // memory address
        sub r6 2 r6
        add r7 r7 craftingGrid
        add r7 r7 r5  // adjust memory address by x
        mlt r5 r5 9  // multiply
        mlt r6 r6 9
        sub r6 19 r6  // y
        add r5 r5 21  // x
        ret
    bge ~+6 r7 0xB0  // furnace bottom slot
        imm r5 30
        imm r6 19
        lod r7 loadedTileEntity
        add r7 r7 2
        ret
    bge ~+6 r7 0xC0  // furnace top slot
        imm r5 30
        imm r6 1
        lod r7 loadedTileEntity
        add r7 r7 3
        ret
    imm r6 0xFF  // out of bounds
ret

//bank2_drawItem function
    //description:
        // draws an item at given x,y
        // where x,y is the top left corner of area (1 top/left of the item itself)
    //inputs:
        // r1: x (preserved)
        // r2: y (preserved)
        // r3: item
        // r4: is item selected? (0 = selected, anything else = not selected)
    //outputs:
        // none
    //storage used:
        // none
.bank2_drawItem
    // draw first rectangle
    out %screen_x1 r1
    out %screen_y1 r2
    add r1 r1 9  // x2
    add r2 r2 9  // y2
    out %screen_x2 r1
    out %screen_y2 r2
    sub r1 r1 8  // adjust x, y to correct position to draw item itself
    sub r2 r2 8
    // check if rectangle needs to be filled or emptied
    bnz .bank2_drawItemNotSelected r4

        // draw selected outline
        in r0 %screen_drawrect
        out %screen_x1 r1  // load inner rectangle coordinates
        out %screen_y1 r2
        add r1 r1 7  // x2
        add r2 r2 7  // y2
        out %screen_x2 r1
        out %screen_y2 r2
        sub r1 r1 7  // adjust x, y back to correct position
        sub r2 r2 7

    .bank2_drawItemNotSelected
    in r0 %screen_clearrect  // clear inner rectangle
    bnz .bank2_drawItemNonZero r3  // check if item exists (ie. not 00000000)

        .bank2_drawItemReturn
        sub r1 r1 1  // preserve x,y
        sub r2 r2 1
        in r0 %screen_nop  // ensure screen queue cleared
        ret

    .bank2_drawItemNonZero
    out %screen_x1 r1  // load correct x1, y1
    out %screen_y1 r2
    bge .bank2_drawItemNonstackable r3 0xF0 // check if item is nonstackable
        // draw stackable item
        bsr r4 r3 4  // get item id
        add r4 r4 TEXTURE_STACKABLE  // draw item texture
        out %screen_texid_drawtex r4

        // draw item count
        and r3 r3 0x0F  // get item count
        add r3 r3 TEXTURE_NUMBER  // get background texture
        add r1 r1 2  // move x,y over to correct position
        add r2 r2 2
        out %screen_x1 r1  // draw background texture
        out %screen_y1 r2
        out %screen_texid_drawtex r3
        add r3 r3 0x10  // get TEXTURE_number texture
        out %screen_texid_drawinvtex r3

        // return
        sub r1 r1 3  // preserve x,y
        sub r2 r2 3
        in r0 %screen_nop  // ensure screen queue cleared
        ret

    .bank2_drawItemNonstackable
        // draw nonstackable item
        and r3 r3 0x0F  // get item id
        add r3 r3 TEXTURE_NONSTACKABLE  // draw item texture
        out %screen_texid_drawtex r3
        jmp .bank2_drawItemReturn  // return
// end bank2_drawItem function


//bank2_drawGUIRow function
    //description:
        // draws a row of items of length r5 starting at x,y
        // pointed to by r6 in memory with r7 selected
    //inputs:
        // r1: x
        // r2: y
        // r5: length
        // r6: memory address of first item
        // r7: item in row selected (>length = none selected)
    //outputs:
        // none
    //storage used:
        // none
.bank2_drawGUIRow
    sub r7 r5 r7  // get loop index of selected item
    .bank2_drawGUIRowLoop
        lod r3 r6  // get item
        sub r4 r5 r7  // check if selected (r7 == r5)
        cal .bank2_drawItem  // draw item
        add r1 r1 11  // increase x by slot size
        add r6 r6 1  // increase memory index
        sub r5 r5 1  // decrease loop counter
        bnz .bank2_drawGUIRowLoop r5 // loop if not done yet
    ret  // return
// end bank2_drawGUIRow function


.bank2_highlightRectangle1
    out %screen_x1 r1
    out %screen_y1 r2
    out %screen_y2 r2
    add r1 r1 9
    out %screen_x2 r1
ret

.bank2_highlightRectangle2
    out %screen_x1 r1
    add r2 r2 9
    out %screen_y2 r2
ret

.bank2_highlightRectangle3
    out %screen_y1 r2
    sub r1 r1 9
    out %screen_x1 r1
ret

.bank2_highlightRectangle4
    out %screen_x2 r1
    sub r2 r2 9
    out %screen_y1 r2
ret

//bank2_drawHighlight function
    //description:
        // draws a highlight around the item at x,y
    //inputs:
        // r1: x (preserved)
        // r2: y (preserved)
.bank2_drawHighlight
    cal .bank2_highlightRectangle1
    in r0 %screen_drawrect
    cal .bank2_highlightRectangle2
    in r0 %screen_drawrect
    cal .bank2_highlightRectangle3
    in r0 %screen_drawrect
    cal .bank2_highlightRectangle4
    in r0 %screen_drawrect
ret


//bank2_clearHighlight function
    //description:
        // clears the highlight around the item at x,y
    //inputs:
        // r1: x (preserved)
        // r2: y (preserved)
.bank2_clearHighlight
    cal .bank2_highlightRectangle1
    in r0 %screen_clearrect
    cal .bank2_highlightRectangle2
    in r0 %screen_clearrect
    cal .bank2_highlightRectangle3
    in r0 %screen_clearrect
    cal .bank2_highlightRectangle4
    in r0 %screen_clearrect
ret


//bank2_drawItemInGrid function
    //description:
        // draws an item at given x,y within a GUI grid
        // where x,y is the top left corner of area (1 top/left of the item itself)
    //inputs:
        // r1: x (preserved)
        // r2: y (preserved)
        // r3: item
    //outputs:
        // none
    //storage used:
        // none
.bank2_drawItemInGrid
    // clear rectangle
    add r1 r1 1  // x1
    add r2 r2 1  // y1
    out %screen_x1 r1
    out %screen_y1 r2
    add r1 r1 7  // x2
    add r2 r2 7  // y2
    out %screen_x2 r1
    out %screen_y2 r2
    sub r1 r1 7  // adjust x, y to correct position to draw item itself
    sub r2 r2 7
    in r0 %screen_clearrect

    out %screen_x1 r1  // load correct x1, y1
    out %screen_y1 r2
    bnz .bank2_drawItemInGridNonZero r3  // check if item exists (ie. not 00000000)

        out %screen_texid_drawtex TEXTURE_GUI_EMPTY  // draw empty item
        .bank2_drawItemInGridReturn
        sub r1 r1 1  // preserve x,y
        sub r2 r2 1
        ret

    .bank2_drawItemInGridNonZero
    bge .bank2_drawItemInGridNonstackable r3 0xF0 // check if item is nonstackable
        // draw stackable item
        bsr r3 r3 4  // get item id
        add r3 r3 TEXTURE_STACKABLE  // draw item texture
        out %screen_texid_drawtex r3
        // no need to draw item count as at most 1 in grid
        jmp .bank2_drawItemInGridReturn  // return

    .bank2_drawItemInGridNonstackable
        // draw nonstackable item
        and r3 r3 0x0F  // get item id
        add r3 r3 TEXTURE_NONSTACKABLE  // draw item texture
        out %screen_texid_drawtex r3
        jmp .bank2_drawItemInGridReturn  // return
// end bank2_drawItemInGrid function


//bank2_drawGUIRowInGrid function
    //description:
        // draws a row of items of length r5 starting at x,y
        // pointed to by r6 in memory with r7 selected
    //inputs:
        // r1: x
        // r2: y
        // r5: length
        // r6: memory address of first item
    //outputs:
        // none
    //storage used:
        // none
.bank2_drawGUIRowInGrid
    .bank2_drawGUIRowInGridLoop
        lod r3 r6  // get item
        cal .bank2_drawItemInGrid  // draw item
        in r0 %screen_nop  // ensure screen queue cleared
        add r1 r1 9  // increase x by slot size
        add r6 r6 1  // increase memory index
        sub r5 r5 1  // decrease loop counter
        bnz .bank2_drawGUIRowInGridLoop r5 // loop if not done yet
    ret  // return
// end bank2_drawGUIRowInGrid function


// draw the inventory part of a GUI
.bank2_drawInventory
    // draw highlight (black rectangle around GUI)
    out %screen_x1 19  // top left x
    out %screen_y1 0  // top left y
    out %screen_x2 76  // bottom right x
    out %screen_y2_clearrect 63  // bottom right y

    // draw borders
    out %screen_x1 20  // top left x
    out %screen_y1 0  // top left y
    out %screen_x2 75  // bottom right x
    out %screen_y2_drawrect 63  // bottom right y

.bank2_drawInventoryOnlyInventoryPart  // skip the top half
    // draw highlight (black rectangle around GUI)
    out %screen_x1 19  // top left x
    out %screen_y1 29  // top left y
    out %screen_x2 76  // bottom right x
    out %screen_y2_clearrect 63  // bottom right y

    // draw borders
    out %screen_x1 20  // top left x
    out %screen_y1 29  // top left y
    out %screen_x2 75  // bottom right x
    out %screen_y2_drawrect 63  // bottom right y

    // draw items
    imm r1 21  // top left X
    imm r2 53  // top left y
    imm r5 5  // length
    imm r6 inventory  // first item
    lod r7 inventorySlot  // selected item
    cal .bank2_drawGUIRow  // draw row of items

    sub r2 r2 12  // move up a row in y coordinate
    imm r1 21  // top left X
    imm r5 5  // length
    lod r7 inventorySlot  // selected item
    sub r7 r7 0x10  // move up a row in selected item
    cal .bank2_drawGUIRow  // draw row of items

    sub r2 r2 11  // move up a row in y coordinate
    imm r1 21  // top left X
    imm r5 5  // length
    lod r7 inventorySlot  // selected item
    sub r7 r7 0x20  // move up a row in selected item
    cal .bank2_drawGUIRow  // draw row of items
ret


.bank2_addItemToInventory
    // input: r7 (item)
    // other registers not necessarily preserved
    imm r1 0
    and r6 r7 0xF0  // item id
    bre .bank2_skipStackLoop r6 0xF0  // skip if nonstackable
    .bank2_addItemToInventoryStackLoop
        add r1 r1 inventory  // check what item is already there
        lod r2 r1
        and r3 r2 0xF0
        bne .bank2_addItemToInventoryStackLoopContinue r3 r6  // ensure same item ID
            and r4 r2 0x0F  // get item counts
            and r5 r7 0x0F
            add r5 r4 r5  // get sum
            bge .bank2_addItemToInventoryStackStackTooBig r5 16  // skip if stack too big
                add r3 r3 r5
                str r1 r3  // store new, bigger stack
                ret  // done
            .bank2_addItemToInventoryStackStackTooBig
            or r2 r2 15
            str r1 r2  // store max size stack
            sub r5 r5 15  // remaining items
            add r7 r6 r5  // new item id
        .bank2_addItemToInventoryStackLoopContinue
        sub r1 r1 inventory
        add r1 r1 1  // continue and check if done
    brl .bank2_addItemToInventoryStackLoop r1 15
        
    .bank2_skipStackLoop
    imm r1 0
    .bank2_addItemToInventoryLoop
        add r1 r1 inventory  // check what item is already there
        lod r2 r1
        bnz ~+3 r2  // no item
            str r1 r7  // store regardless of what it is
            ret  // done
        bge .bank2_addItemToInventoryLoopContinue r7 0xF0  // skip if nonstackable
        and r3 r2 0xF0  // get item id
        bne .bank2_addItemToInventoryLoopContinue r6 r3  // skip if not same item id
            and r4 r2 0x0F  // get item counts
            and r5 r7 0x0F
            add r5 r4 r5  // get sum
            bge .bank2_addItemToInventoryStackTooBig r5 16  // skip if stack too big
                add r3 r3 r5
                str r1 r3  // store new, bigger stack
                ret  // done
            .bank2_addItemToInventoryStackTooBig
            or r2 r2 15
            str r1 r2  // store max size stack
            sub r5 r5 15  // remaining items
            add r7 r6 r5  // new item id
        .bank2_addItemToInventoryLoopContinue
        sub r1 r1 inventory
        add r1 r1 1  // continue and check if done
    brl .bank2_addItemToInventoryLoop r1 15
ret






// try crafting - same subroutine for both 2x2 and 3x3 grids
.bank2_tryCrafting
    imm r1 15  // push entire inventory to stack - in case of not enough materials
    imm r2 inventory
    .bank2_tryCraftingToStackLoop
        lod r3 r2
        psh r3
        add r2 r2 1
        sub r1 r1 1
        bnz .bank2_tryCraftingToStackLoop r1

    imm r1 0  // index in crafting grid
    .bank2_tryCraftingMainLoop
        add r2 r1 craftingGrid  // get item id
        lod r2 r2
        and r2 r2 0xF0
        brz .bank2_tryCraftingLoopContinue r2  // continue if no item in that slot
        imm r3 0  // index in inventory
        .bank2_tryCraftingSubLoop
            add r4 r3 inventory  // get inventory item id
            lod r4 r4
            and r5 r4 0xF0  // check if same item id
            bre .bank2_tryCraftingLoopItemMatch r2 r5  // match!
            add r3 r3 1  // no match - continue
            brl .bank2_tryCraftingSubLoop r3 15  // if more inventory left, continue
        jmp .bank2_tryCraftingFailure  // no items of this id remain in inventory

        .bank2_tryCraftingLoopItemMatch
        sub r4 r4 1  // subtract 1 from item count
        and r5 r4 0x0F  // check if no items left in stack
        bnz ~+2 r5
            imm r4 0  // reset stack if no items left
        add r3 r3 inventory  // store item back
        str r3 r4
        .bank2_tryCraftingLoopContinue
        add r1 r1 1  // move along to next slot in crafting grid
        brl .bank2_tryCraftingMainLoop r1 9  // continue if not done all slots

    // success
        lod r7 craftingOutput  // add crafting output to inventory
        cal .bank2_addItemToInventory

        imm r1 15  // pop the (garbage) inventory off the stack
        .bank2_tryCraftingClearStackLoop
            pop r0
            sub r1 r1 1
            bnz .bank2_tryCraftingClearStackLoop r1

        str permanentSelectedSlot 0xFF  // reset permanent selected slot if successful
        cal .bank2_drawInventoryOnlyInventoryPart  // redraw inventory
    ret

    // failure
    .bank2_tryCraftingFailure
        imm r2 inventory  // pop entire inventory from stack
        add r2 r2 14
        .bank2_tryCraftingFromStackLoop
            pop r3
            str r2 r3
            sub r2 r2 1
            bge .bank2_tryCraftingFromStackLoop r2 inventory
        ret




// PLAYER INVENTORY (2x2 crafting grid)



// draw slot with highlight
.bank2_inventoryDrawSlotWithHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    bge ~+4 r6 28
        // within the crafting grid
        cal .bank2_drawItemInGrid
        cal .bank2_drawHighlight
        ret
    // outside the crafting grid
    imm r4 0  // selected item
    cal .bank2_drawItem
ret

// draw slot without highlight (also clears highlight)
.bank2_inventoryDrawSlotWithoutHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    bge ~+4 r6 28
        // within the crafting grid
        cal .bank2_drawItemInGrid
        cal .bank2_clearHighlight
        ret
    // outside the crafting grid
    imm r4 1  // not selected item
    cal .bank2_drawItem
ret

// reset crafting grid
.bank2_reset2x2CraftingGrid
    imm r1, craftingGrid  // memory address
    .bank2_reset2x2CraftingGridLoop  // can use loop counter on chungus
        str r1 0  // store empty item
        inc r1 r1
        ble .bank2_reset2x2CraftingGridLoop r1 craftingOutput  // loop if not done

    // draw background of grid
    out %screen_x1 26
    out %screen_y1 9
    out %screen_x2 44
    out %screen_y2_clearrect 27

    // draw items in grid
    imm r7 craftingGrid  // memory address
    imm r2 9  // y

    imm r1 26  // x
    imm r5 2  // length
    mov r6 r7  // memory address
    cal .bank2_drawGUIRowInGrid

    imm r2 18  // y
    imm r1 26  // x
    imm r5 2  // length
    add r6 r7 3  // memory address
    cal .bank2_drawGUIRowInGrid

    // draw output item
    imm r1 60  // x
    imm r2 14  // y
    imm r3 0  // no item
    imm r4 1  // not highlighted
    cal .bank2_drawItem
ret


// load GUI for open inventory
.bank2_loadInventoryGUI
    // draw inventory part and outline
    cal .bank2_drawInventory

    // draw crafting grid and output item
    cal .bank2_reset2x2CraftingGrid

    // draw "INVENTORY"
    out %screen_y1 1  // y
    out %screen_x1 40  // IN
    out %screen_texid_drawinvtex 0x70
    out %screen_x1 48  // VE
    out %screen_texid_drawinvtex 0x71
    out %screen_x1 56  // NT
    out %screen_texid_drawinvtex 0x72
    out %screen_x1 64  // OR
    out %screen_texid_drawinvtex 0x73
    out %screen_x1 72  // Y
    out %screen_texid_drawinvtex 0x74
    in r0 %screen_nop  // wait for screen queue to clear

    // draw arrow
    out %screen_x1 46  // x
    out %screen_y1 15  // y
    imm r1 TEXTURE_GUI_ARROW
    out %screen_texid_drawinvtex r1
    out %screen_x1 54  // new x
    add r1 r1 1
    out %screen_texid_drawinvtex r1

    // render and wait for inputs
    in r0 %screen_buffer

.bank2_inventoryLoop
    out %playerinput r0 //synchronize playerInput device

    //handle inputs

        in r0 %playerinput //get input

        in r1 %playerinput //is open/close inventory pressed?
        bnz .continueFromClosingInventory r1
        
    // handle inventory movement
        in r1 %playerinput  // inventory movement
        lod r2 inventorySlot
        brz .bank2_inventorySkipMovement r1  // skip if no movement

        lod r7 inventorySlot
        psh r1
        cal .bank2_inventoryDrawSlotWithoutHighlight  // remove highlight from previous slot
        pop r1

        lod r2 inventorySlot
        brl .bank2_inventoryMoveWithinInventory r2 0x30

            // moving within crafting grid
            bne ~+5 r1 0x10  // move up
                brl ~+3 r2 0x60  // top of crafting grid
                    imm r2 0x00  // move to bottom of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+5 r1 0xF0  // move down
                bge ~+3 r2 0x60  // bottom of crafting grid
                    imm r2 0x20  // move to top of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+3 r1 0x0F  // move left
                sub r2 r2 1
                and r2 r2 0xF1  // stay within grid
            bne ~+3 r1 0x01  // move right
                add r2 r2 1
                and r2 r2 0xF1  // stay within grid

            jmp .bank2_inventorySkipMovement

        .bank2_inventoryMoveWithinInventory

            // moving within inventory
            bne ~+5 r1 0x10  // move up
                brl ~+3 r2 0x20  // top of inventory
                    imm r2 0x50  // move to crafting grid
                    jmp ~+2
                add r2 r2 r1
            bne ~+5 r1 0xF0  // move down
                bge ~+3 r2 0x10  // bottom of inventory
                    add r2 r2 0x20  // move to top of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+6 r1 0x0F  // move left
                and r3 r2 0x0F
                bne ~+3 r3 0x00  // left of inventory
                    add r2 r2 0x04  // move to right of inventory
                    jmp ~+2
                sub r2 r2 1
            bne ~+6 r1 0x01  // move right
                and r3 r2 0x0F
                bne ~+3 r3 0x04  // right of inventory
                    sub r2 r2 0x04  // move to left of inventory
                    jmp ~+2
                add r2 r2 1

        .bank2_inventorySkipMovement
            str inventorySlot r2  // draw selected slot
            mov r7 r2
            cal .bank2_inventoryDrawSlotWithHighlight

            in r1 %playerinput  // craft?
            brz .bank2_inventorySkipTryCrafting r1  // skip if not necessary
            lod r1 craftingOutput
            brz .bank2_inventorySkipTryCrafting r1  // skip if no crafting output

            cal .bank2_tryCrafting  // try and craft
            lod r7 inventorySlot  // redraw inventory slot (incase modified)
            cal .bank2_inventoryDrawSlotWithHighlight

        .bank2_inventorySkipTryCrafting
            lod r7 permanentSelectedSlot  // highlight permanent selected slot (if any)
            cal .bank2_inventoryDrawSlotWithHighlight

            in r1 %playerinput  // select item?
            brz .bank2_inventorySkipSelectItem r1  // skip if not necessary

            lod r1 permanentSelectedSlot  // get current permanent slot
            lod r2 inventorySlot
            bne .bank2_inventorySelectedAlready r1 0xFF  // already selected
                // select new slot
                bge .bank2_inventorySkipSelectItem r2 0x50  // out of bounds - do not select
                str permanentSelectedSlot r2  // set new permanent slot
                // NOTE: slot already highlighted (in previous section)
                jmp .bank2_inventorySkipSelectItem
            
            .bank2_inventorySelectedAlready
            // slot already selected
            mov r7 r1  // get memory address of old slot
            cal .bank2_inventoryGetSlot
            lod r3 r7
            mov r7 r2  // get memory address of new slot
            cal .bank2_inventoryGetSlot
            lod r4 r7
            str r7 r3  // move item(s) over
            psh r4  // preserve items
            mov r7 r2
            cal .bank2_inventoryDrawSlotWithHighlight
            pop r4
            lod r1 permanentSelectedSlot
            lod r2 inventorySlot
            bge .bank2_inventoryCheckCrafting r2 0x50  // out of bounds - only move

                // within bounds
                mov r7 r1  // get memory address of old slot
                cal .bank2_inventoryGetSlot
                str r7 r4  // swap items the other way
                mov r7 r1  // redraw and remove highlight
                cal .bank2_inventoryDrawSlotWithoutHighlight
                str permanentSelectedSlot 0xFF  // remove permanent selected slot
                lod r7 inventorySlot  // redraw slot if needed
                cal .bank2_inventoryDrawSlotWithHighlight
                jmp .bank2_inventorySkipSelectItem
        
        .bank2_inventoryCheckCrafting
            // check if a crafting recipe has been made possible
            out %craftrom 0xFF  // set to crafting mode
            imm r1 9  // output full crafting grid
            imm r2 craftingGrid
            .bank2_inventoryCheckCraftingLoop
                lod r3 r2
                out %craftrom r3
                add r2 r2 1
                sub r1 r1 1
                bnz .bank2_inventoryCheckCraftingLoop r1
            in r3 %craftrom  // get item (if any)
            str craftingOutput r3  // store
            // draw output item
            imm r1 60  // x
            imm r2 14  // y
            imm r4 1  // not highlighted
            cal .bank2_drawItem

        .bank2_inventorySkipSelectItem

            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage

            in r1 %playerinput  // clear crafting grid?
            brz .bank2_inventoryContinue r1
                cal .bank2_reset2x2CraftingGrid
                lod r7 inventorySlot  // redraw inventory slot
                cal .bank2_inventoryDrawSlotWithHighlight

    .bank2_inventoryContinue
    // render and wait for inputs
    in r0 %screen_buffer
    jmp .bank2_inventoryLoop




// CRAFTING INVENTORY (3x3 crafting grid)




// draw slot with highlight
.bank2_craftingDrawSlotWithHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    bge ~+4 r6 28
        // within the crafting grid
        cal .bank2_drawItemInGrid
        cal .bank2_drawHighlight
        ret
    // outside the crafting grid
    imm r4 0  // selected item
    cal .bank2_drawItem
ret

// draw slot without highlight (also clears highlight)
.bank2_craftingDrawSlotWithoutHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    bge ~+4 r6 28
        // within the crafting grid
        cal .bank2_drawItemInGrid
        cal .bank2_clearHighlight
        ret
    // outside the crafting grid
    imm r4 1  // not selected item
    cal .bank2_drawItem
ret

// reset crafting grid
.bank2_reset3x3CraftingGrid
    imm r1, craftingGrid  // memory address
    .bank2_reset3x3CraftingGridLoop  // can use loop counter on chungus
        str r1 0  // store empty item
        inc r1 r1
        ble .bank2_reset3x3CraftingGridLoop r1 craftingOutput  // loop if not done

    // draw background of grid
    out %screen_x1 21
    out %screen_y1 1
    out %screen_x2 48
    out %screen_y2_clearrect 28

    // draw items in grid
    imm r7 craftingGrid  // memory address
    imm r2 1  // y

    imm r1 21  // x
    imm r5 3  // length
    mov r6 r7  // memory address
    cal .bank2_drawGUIRowInGrid

    imm r2 10  // y
    imm r1 21  // x
    imm r5 3  // length
    add r6 r7 3  // memory address
    cal .bank2_drawGUIRowInGrid

    imm r2 19  // y
    imm r1 21  // x
    imm r5 3  // length
    add r6 r7 6  // memory address
    cal .bank2_drawGUIRowInGrid

    // draw output item
    imm r1 65  // x
    imm r2 10  // y
    imm r3 0  // no item
    imm r4 1  // not highlighted
    cal .bank2_drawItem
ret


// load GUI for open crafting grid
.bank2_loadCraftingGUI
    // draw inventory part and outline
    cal .bank2_drawInventory

    // draw crafting grid and output item
    cal .bank2_reset3x3CraftingGrid

    // draw "INVENTORY"
    out %screen_y1 1  // y
    out %screen_x1 56  // CR
    out %screen_texid_drawinvtex 0x75
    out %screen_x1 64  // AF
    out %screen_texid_drawinvtex 0x76
    out %screen_x1 72  // T
    out %screen_texid_drawinvtex 0x77
    in r0 %screen_nop  // wait for screen queue to clear

    // draw arrow
    out %screen_x1 51  // x
    out %screen_y1 11  // y
    imm r1 TEXTURE_GUI_ARROW
    out %screen_texid_drawinvtex r1
    out %screen_x1 59  // new x
    add r1 r1 1
    out %screen_texid_drawinvtex r1

    // render and wait for inputs
    in r0 %screen_buffer

.bank2_craftingLoop
    out %playerinput r0 //synchronize playerInput device

    //handle inputs

        in r0 %playerinput //get input

        in r1 %playerinput //is open/close inventory pressed?
        bnz .continueFromClosingInventory r1
        
    // handle inventory movement
        in r1 %playerinput  // inventory movement
        lod r2 inventorySlot
        brz .bank2_craftingSkipMovement r1  // skip if no movement

        lod r7 inventorySlot
        psh r1
        cal .bank2_craftingDrawSlotWithoutHighlight  // remove highlight from previous slot
        pop r1

        lod r2 inventorySlot
        brl .bank2_craftingMoveWithinInventory r2 0x30

            // moving within crafting grid
            bne ~+5 r1 0x10  // move up
                brl ~+3 r2 0x90  // top of crafting grid
                    imm r2 0x00  // move to bottom of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+5 r1 0xF0  // move down
                bge ~+3 r2 0x80  // bottom of crafting grid
                    imm r2 0x20  // move to top of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+6 r1 0x0F  // move left
                and r3 r2 0x0F
                bne ~+3 r3 0x00  // left of crafting grid
                    add r2 r2 0x02  // move to right of crafting grid
                    jmp ~+2
                sub r2 r2 1
            bne ~+6 r1 0x01  // move right
                and r3 r2 0x0F
                bne ~+3 r3 0x02  // right of crafting grid
                    sub r2 r2 0x02  // move to left of crafting grid
                    jmp ~+2
                add r2 r2 1

            jmp .bank2_craftingSkipMovement

        .bank2_craftingMoveWithinInventory

            // moving within inventory
            bne ~+5 r1 0x10  // move up
                brl ~+3 r2 0x20  // top of inventory
                    imm r2 0x70  // move to crafting grid
                    jmp ~+2
                add r2 r2 r1
            bne ~+5 r1 0xF0  // move down
                bge ~+3 r2 0x10  // bottom of inventory
                    add r2 r2 0x20  // move to top of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+6 r1 0x0F  // move left
                and r3 r2 0x0F
                bne ~+3 r3 0x00  // left of inventory
                    add r2 r2 0x04  // move to right of inventory
                    jmp ~+2
                sub r2 r2 1
            bne ~+6 r1 0x01  // move right
                and r3 r2 0x0F
                bne ~+3 r3 0x04  // right of inventory
                    sub r2 r2 0x04  // move to left of inventory
                    jmp ~+2
                add r2 r2 1

        .bank2_craftingSkipMovement
            str inventorySlot r2  // draw selected slot
            mov r7 r2
            cal .bank2_craftingDrawSlotWithHighlight

            in r1 %playerinput  // craft?
            brz .bank2_craftingSkipTryCrafting r1  // skip if not necessary
            lod r1 craftingOutput
            brz .bank2_craftingSkipTryCrafting r1  // skip if no crafting output

            cal .bank2_tryCrafting  // try and craft
            lod r7 inventorySlot  // redraw inventory slot (incase modified)
            cal .bank2_craftingDrawSlotWithHighlight

        .bank2_craftingSkipTryCrafting
            lod r7 permanentSelectedSlot  // highlight permanent selected slot (if any)
            cal .bank2_craftingDrawSlotWithHighlight

            in r1 %playerinput  // select item?
            brz .bank2_craftingSkipSelectItem r1  // skip if not necessary

            lod r1 permanentSelectedSlot  // get current permanent slot
            lod r2 inventorySlot
            bne .bank2_craftingSelectedAlready r1 0xFF  // already selected
                // select new slot
                bge .bank2_craftingSkipSelectItem r2 0x70  // out of bounds - do not select
                str permanentSelectedSlot r2  // set new permanent slot
                // NOTE: slot already highlighted (in previous section)
                jmp .bank2_craftingSkipSelectItem
            
            .bank2_craftingSelectedAlready
            // slot already selected
            mov r7 r1  // get memory address of old slot
            cal .bank2_inventoryGetSlot
            lod r3 r7
            mov r7 r2  // get memory address of new slot
            cal .bank2_inventoryGetSlot
            lod r4 r7
            str r7 r3  // move item(s) over
            psh r4  // preserve items
            mov r7 r2
            cal .bank2_craftingDrawSlotWithHighlight
            pop r4
            lod r1 permanentSelectedSlot
            lod r2 inventorySlot
            bge .bank2_craftingCheckCrafting r2 0x70  // out of bounds - only move

                // within bounds
                mov r7 r1  // get memory address of old slot
                cal .bank2_inventoryGetSlot
                str r7 r4  // swap items the other way
                mov r7 r1  // redraw and remove highlight
                cal .bank2_craftingDrawSlotWithoutHighlight
                str permanentSelectedSlot 0xFF  // remove permanent selected slot
                lod r7 inventorySlot  // redraw slot if needed
                cal .bank2_craftingDrawSlotWithHighlight
                jmp .bank2_craftingSkipSelectItem
        
        .bank2_craftingCheckCrafting
            // check if a crafting recipe has been made possible
            out %craftrom 0xFF  // set to crafting mode
            imm r1 9  // output full crafting grid
            imm r2 craftingGrid
            .bank2_craftingCheckCraftingLoop
                lod r3 r2
                out %craftrom r3
                add r2 r2 1
                sub r1 r1 1
                bnz .bank2_craftingCheckCraftingLoop r1
            in r3 %craftrom  // get item (if any)
            str craftingOutput r3  // store
            // draw output item
            imm r1 65  // x
            imm r2 10  // y
            imm r4 1  // not highlighted
            cal .bank2_drawItem

        .bank2_craftingSkipSelectItem

            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage
            in r0 %playerinput  // garbage

            in r1 %playerinput  // clear crafting grid?
            brz .bank2_craftingContinue r1
                cal .bank2_reset3x3CraftingGrid
                lod r7 inventorySlot  // redraw inventory slot
                cal .bank2_craftingDrawSlotWithHighlight

    .bank2_craftingContinue
    // render and wait for inputs
    in r0 %screen_buffer
    jmp .bank2_craftingLoop



// FURNACE GUI




// draw slot with highlight
.bank2_furnaceDrawSlotWithHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    bge ~+4 r6 28
        // within the furnace
        cal .bank2_drawItemInGrid
        cal .bank2_drawHighlight
        ret
    // outside the furnace
    imm r4 0  // selected item
    cal .bank2_drawItem
ret

// draw slot without highlight (also clears highlight)
.bank2_furnaceDrawSlotWithoutHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    bge ~+4 r6 28
        // within the furnace
        cal .bank2_drawItemInGrid
        cal .bank2_clearHighlight
        ret
    // outside the furnace
    imm r4 1  // not selected item
    cal .bank2_drawItem
ret

// draw arrow to show progress and items
.bank2_drawFurnaceContents
    // draw 3 slots in furnace
        // fuel
        lod r6 loadedTileEntity
        add r6 r6 2
        imm r1 30  // x
        imm r2 19  // y
        imm r5 1
        lod r7 inventorySlot
        sub r7 r7 0xA0
        cal .bank2_drawGUIRow
        // item
        imm r1 30  // x
        imm r2 1  // y
        imm r5 1
        lod r7 inventorySlot
        sub r7 r7 0xB0
        cal .bank2_drawGUIRow
        // result
        imm r1 56  // x
        imm r2 10  // y
        imm r5 1
        imm r7 128
        cal .bank2_drawGUIRow
    
    // draw arrow
    out %screen_x1 42  // x
    out %screen_y1 11  // y
    imm r1 TEXTURE_GUI_ARROW
    out %screen_texid_drawinvtex r1
    out %screen_x1 50  // new x
    add r1 r1 1
    out %screen_texid_drawinvtex r1

    // TODO: fill in based on timer value

ret


// load GUI for open furnace
.bank2_loadFurnaceGUI
    // draw inventory part and outline
    cal .bank2_drawInventory

    // draw furnace contents
    cal .bank2_drawFurnaceContents

    // draw smelting symbol
    out %screen_x1 31
    out %screen_y1 12
    out %screen_texid_drawinvtex TEXTURE_GUI_SMELTING

    // draw "INVENTORY"
    out %screen_y1 1  // y
    out %screen_x1 48  // FU
    out %screen_texid_drawinvtex 0x78
    out %screen_x1 56  // RN
    out %screen_texid_drawinvtex 0x79
    out %screen_x1 64  // AC
    out %screen_texid_drawinvtex 0x7A
    out %screen_x1 72  // E
    out %screen_texid_drawinvtex 0x7B
    in r0 %screen_nop  // wait for screen queue to clear

    // render and wait for inputs
    in r0 %screen_buffer

.bank2_furnaceLoop
    out %playerinput r0 //synchronize playerInput device

    //handle inputs

        in r0 %playerinput //get input

        in r1 %playerinput //is open/close inventory pressed?
        bnz .continueFromClosingInventory r1
        
    // handle inventory movement
        in r1 %playerinput  // inventory movement
        lod r2 inventorySlot
        brz .bank2_furnaceSkipMovement r1  // skip if no movement

        lod r7 inventorySlot
        psh r1
        cal .bank2_furnaceDrawSlotWithoutHighlight  // remove highlight from previous slot
        pop r1

        lod r2 inventorySlot
        brl .bank2_furnaceMoveWithinInventory r2 0x30

            // moving within furnace
            bne ~+5 r1 0x10  // move up
                brl ~+3 r2 0xB0  // top of furnace
                    imm r2 0x00  // move to bottom of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+5 r1 0xF0  // move down
                bge ~+3 r2 0xB0  // bottom of furnace
                    imm r2 0x20  // move to top of inventory
                    jmp ~+2
                add r2 r2 r1
            // note: can't move left or right within furnace GUI

            jmp .bank2_furnaceSkipMovement

        .bank2_furnaceMoveWithinInventory

            // moving within inventory
            bne ~+5 r1 0x10  // move up
                brl ~+3 r2 0x20  // top of inventory
                    imm r2 0xA0  // move to furnace
                    jmp ~+2
                add r2 r2 r1
            bne ~+5 r1 0xF0  // move down
                bge ~+3 r2 0x10  // bottom of inventory
                    add r2 r2 0x20  // move to top of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+6 r1 0x0F  // move left
                and r3 r2 0x0F
                bne ~+3 r3 0x00  // left of inventory
                    add r2 r2 0x04  // move to right of inventory
                    jmp ~+2
                sub r2 r2 1
            bne ~+6 r1 0x01  // move right
                and r3 r2 0x0F
                bne ~+3 r3 0x04  // right of inventory
                    sub r2 r2 0x04  // move to left of inventory
                    jmp ~+2
                add r2 r2 1

        .bank2_furnaceSkipMovement
            str inventorySlot r2  // draw selected slot
            mov r7 r2
            cal .bank2_furnaceDrawSlotWithHighlight

            lod r7 permanentSelectedSlot  // highlight permanent selected slot (if any)
            cal .bank2_furnaceDrawSlotWithHighlight

            in r0 %playerinput  // garbage
            in r1 %playerinput  // select item?
            brz .bank2_furnaceSkipSelectItem r1  // skip if not necessary

            lod r1 permanentSelectedSlot  // get current permanent slot
            lod r2 inventorySlot
            bne .bank2_furnaceSelectedAlready r1 0xFF  // already selected
                // select new slot
                bge .bank2_furnaceSkipSelectItem r2 0xA0  // out of bounds - do not select
                str permanentSelectedSlot r2  // set new permanent slot
                // NOTE: slot already highlighted (in previous section)
                jmp .bank2_furnaceSkipSelectItem

            .bank2_furnaceSelectedAlready
            // slot already selected
            mov r7 r1  // get memory address of old slot
            cal .bank2_inventoryGetSlot
            lod r3 r7
            mov r7 r2  // get memory address of new slot
            cal .bank2_inventoryGetSlot
            lod r4 r7
            str r7 r3  // move item(s) over
            psh r4  // preserve items
            mov r7 r2
            cal .bank2_furnaceDrawSlotWithHighlight
            pop r4
            lod r1 permanentSelectedSlot
            mov r7 r1  // get memory address of old slot
            cal .bank2_inventoryGetSlot
            str r7 r4  // swap items the other way
            mov r7 r1  // redraw and remove highlight
            cal .bank2_furnaceDrawSlotWithoutHighlight
            str permanentSelectedSlot 0xFF  // remove permanent selected slot
            lod r7 inventorySlot  // redraw slot if needed
            cal .bank2_furnaceDrawSlotWithHighlight
            jmp .bank2_craftingSkipSelectItem
        
        .bank2_furnaceSkipSelectItem

            // TODO: add furnace loop code here

            in r1 %playerinput  // if nonzero, take from furnace
            brz ~+1 r1

            cal .bank2_drawFurnaceContents  // redraws furnace contents incase modified

    .bank2_furnaceContinue
    // render and wait for inputs
    in r0 %screen_buffer
    jmp .bank2_furnaceLoop






// CHEST GUI




// draw slot with highlight
.bank2_chestDrawSlotWithHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    imm r4 0  // selected item
    cal .bank2_drawItem
ret

// draw slot without highlight (also clears highlight)
.bank2_chestDrawSlotWithoutHighlight
    // input: r7 (slot)
    // does not preserve registers
    cal .bank2_inventoryGetSlot
    bne ~+2 r6 0xFF  // out of bounds - skip
        ret
    lod r3 r7  // get item
    mov r1 r5  // load x and y
    mov r2 r6
    imm r4 1  // not selected item
    cal .bank2_drawItem
ret


// load GUI for open crafting grid
.bank2_loadChestGUI
    // draw inventory part and outline
    cal .bank2_drawInventory

    // draw items
    imm r1 21  // top left X
    imm r2 18  // top left y
    imm r5 5  // length
    lod r6 loadedTileEntity  // first item
    add r6 r6 2
    lod r7 inventorySlot  // selected item
    sub r7 r7 0x30  // move up a row in selected item
    cal .bank2_drawGUIRow  // draw row of items

    sub r2 r2 11  // move up a row in y coordinate
    imm r1 21  // top left X
    imm r5 5  // length
    lod r7 inventorySlot  // selected item
    sub r7 r7 0x40  // move up a row in selected item
    cal .bank2_drawGUIRow  // draw row of items

    // draw "INVENTORY"
    out %screen_y1 1  // y
    out %screen_x1 56  // CH
    out %screen_texid_drawinvtex 0x7c
    out %screen_x1 64  // ES
    out %screen_texid_drawinvtex 0x7d
    out %screen_x1 72  // T
    out %screen_texid_drawinvtex 0x7e
    in r0 %screen_nop  // wait for screen queue to clear

    // render and wait for inputs
    in r0 %screen_buffer

.bank2_chestLoop
    out %playerinput r0 //synchronize playerInput device

    //handle inputs

        in r0 %playerinput //get input

        in r1 %playerinput //is open/close inventory pressed?
        bnz .continueFromClosingInventory r1
        
    // handle inventory movement
        in r1 %playerinput  // inventory movement
        lod r2 inventorySlot
        brz .bank2_chestSkipMovement r1  // skip if no movement

        lod r7 inventorySlot
        psh r1
        cal .bank2_chestDrawSlotWithoutHighlight  // remove highlight from previous slot
        pop r1

        lod r2 inventorySlot
            // moving within inventory
            bne ~+5 r1 0x10  // move up
                brl ~+3 r2 0x50  // top of inventory
                    sub r2 r2 0x40  // move to crafting grid
                    jmp ~+2
                add r2 r2 r1
            bne ~+5 r1 0xF0  // move down
                bge ~+3 r2 0x10  // bottom of inventory
                    add r2 r2 0x40  // move to top of inventory
                    jmp ~+2
                add r2 r2 r1
            bne ~+6 r1 0x0F  // move left
                and r3 r2 0x0F
                bne ~+3 r3 0x00  // left of inventory
                    add r2 r2 0x04  // move to right of inventory
                    jmp ~+2
                sub r2 r2 1
            bne ~+6 r1 0x01  // move right
                and r3 r2 0x0F
                bne ~+3 r3 0x04  // right of inventory
                    sub r2 r2 0x04  // move to left of inventory
                    jmp ~+2
                add r2 r2 1

        .bank2_chestSkipMovement
            str inventorySlot r2  // draw selected slot
            mov r7 r2
            cal .bank2_chestDrawSlotWithHighlight

            in r1 %playerinput  // craft? (unnecessary)

            lod r7 permanentSelectedSlot  // highlight permanent selected slot (if any)
            cal .bank2_chestDrawSlotWithHighlight

            in r1 %playerinput  // select item?
            brz .bank2_chestSkipSelectItem r1  // skip if not necessary

            lod r1 permanentSelectedSlot  // get current permanent slot
            lod r2 inventorySlot
            bne .bank2_chestSelectedAlready r1 0xFF  // already selected
                // select new slot
                bge .bank2_chestSkipSelectItem r2 0x70  // out of bounds - do not select
                str permanentSelectedSlot r2  // set new permanent slot
                // NOTE: slot already highlighted (in previous section)
                jmp .bank2_chestSkipSelectItem
            
            .bank2_chestSelectedAlready
            // slot already selected
            mov r7 r1  // get memory address of old slot
            cal .bank2_inventoryGetSlot
            lod r3 r7
            mov r7 r2  // get memory address of new slot
            cal .bank2_inventoryGetSlot
            lod r4 r7
            str r7 r3  // move item(s) over
            psh r4  // preserve items
            mov r7 r2
            cal .bank2_chestDrawSlotWithHighlight
            pop r4
            lod r1 permanentSelectedSlot
            mov r7 r1  // get memory address of old slot
            cal .bank2_inventoryGetSlot
            str r7 r4  // swap items the other way
            mov r7 r1  // redraw and remove highlight
            cal .bank2_chestDrawSlotWithoutHighlight
            str permanentSelectedSlot 0xFF  // remove permanent selected slot
            lod r7 inventorySlot  // redraw slot if needed
            cal .bank2_chestDrawSlotWithHighlight
    .bank2_chestSkipSelectItem
    // render and wait for inputs
    in r0 %screen_buffer
    jmp .bank2_chestLoop
